<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="Climb from Earth to space! Race against time, unlock 35+ character skins, and reach for the stars in this addictive mobile climbing game.">
    <meta name="theme-color" content="#4a90e2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Mountain Climber - Race to the Summit!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            min-height: 100vh;
            min-height: calc(var(--vh, 1vh) * 100);
            min-height: -webkit-fill-available;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: #87ceeb;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            width: 100%;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            cursor: pointer;
            touch-action: none;
            z-index: 1;
        }

        /* HUD Elements - Mobile Optimized */
        .hud {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: 10px;
            right: 10px;
            z-index: 5;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
        }

        .hud-left, .hud-right {
            background: rgba(30, 25, 20, 0.92);
            padding: 14px 20px;
            border: 1px solid rgba(200, 170, 130, 0.3);
            border-bottom: 2px solid rgba(200, 170, 130, 0.4);
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            font-size: 15px;
            letter-spacing: 0.3px;
        }

        .power-bar {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 20px);
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            z-index: 5;
            display: none;
        }

        .power-bar-label {
            text-align: center;
            color: rgba(255, 255, 255, 0.95);
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .power-bar-container {
            width: 100%;
            height: 50px;
            background: rgba(25, 20, 15, 0.93);
            border: 1px solid rgba(139, 90, 60, 0.4);
            border-top: 1px solid rgba(139, 90, 60, 0.2);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
        }

        .power-fill {
            height: 100%;
            background: linear-gradient(to bottom, #8a9560 0%, #7a8450 50%, #6a7440 100%);
            transition: width 0.1s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .power-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-weight: 700;
            font-size: 19px;
            pointer-events: none;
            z-index: 2;
        }

        .instruction {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 100px);
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            text-align: center;
            z-index: 5;
            max-width: 90%;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            display: none;
        }

        /* Height Ruler - Mobile Optimized */
        }

        /* Leaderboard - Mobile Optimized */
        #leaderboard {
            position: absolute;
            top: calc(env(safe-area-inset-top, 10px) + 10px);
            right: 10px;
            background: rgba(40, 30, 20, 0.95);
            padding: 12px 16px;
            border-radius: 12px;
            border: 2px solid rgba(139, 115, 85, 0.8);
            min-width: 160px;
            max-width: 200px;
            
            z-index: 10;
            display: none;
            
        }

        /* Screens - Mobile Optimized */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(101, 67, 33, 0.95);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            padding: env(safe-area-inset-top, 20px) env(safe-area-inset-right, 20px) env(safe-area-inset-bottom, 20px) env(safe-area-inset-left, 20px);
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
        }

        .title {
            font-size: 52px;
            font-weight: 800;
            color: #fff;
            margin-bottom: 12px;
            text-align: center;
            line-height: 1.1;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-size: 17px;
            color: rgba(212, 167, 138, 0.9);
            margin-bottom: 35px;
            text-align: center;
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        .btn {
            padding: 16px 32px;
            margin: 10px;
            font-size: 17px;
            font-weight: 600;
            color: #fff;
            background: #8b7355;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-bottom: 2px solid rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            min-width: 220px;
            max-width: 90%;
            letter-spacing: 0.3px;
        }

        .btn:hover {
            background: #9a8365;
            border-bottom-width: 1px;
            transform: translateY(1px);
        }

        .btn:active {
            background: #6b5335;
            border-bottom-width: 1px;
            transform: translateY(1px);
        }

        .btn-secondary {
            background: #9b6baa;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .btn-secondary:hover {
            background: #ab7bba;
        }

        .coins-display {
            font-size: 20px;
            color: #ffd700;
            font-weight: 700;
            margin-top: 25px;
            letter-spacing: 0.5px;
        }

        .score-display {
            font-size: 36px;
            color: #fff;
            font-weight: 700;
            margin: 25px 0;
            letter-spacing: -0.5px;
        }

        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #7a6550;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            margin-top: 20px;
            
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        body {
            animation: fadeIn 0.5s ease-in;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="spinner"></div>
        <div class="loading-text">‚õ∞Ô∏è Loading Mountain Climber...</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div class="hud">
        <div class="hud-left" id="heightDisplay">Height: 0m</div>
        <div class="hud-right" id="coinsDisplay">ü™ô 0</div>
    </div>

    </div>
    
    <!-- Warp UI -->
    <div id="warpUI" style="position: fixed; top: calc(env(safe-area-inset-top, 20px) + 20px); right: calc(env(safe-area-inset-right, 20px) + 20px); z-index: 15; background: rgba(30, 25, 20, 0.95); padding: 12px 16px; border: 1px solid rgba(200, 170, 130, 0.3); border-bottom: 2px solid rgba(200, 170, 130, 0.4); border-radius: 6px; display: none; flex-direction: column; gap: 8px; min-width: 180px;">
        <div style="color: #ffd700; font-weight: 700; font-size: 14px; letter-spacing: 0.3px; text-align: center;">‚ö° WARP</div>
        <input type="number" id="warpInput" placeholder="Altitude (m)" min="0" step="10" onkeypress="if(event.key==='Enter')game.warpToAltitude()" style="padding: 8px 12px; font-size: 15px; font-weight: 600; background: rgba(50, 40, 30, 0.8); border: 1px solid rgba(200, 170, 130, 0.3); border-radius: 4px; color: #fff; text-align: center; font-family: 'Arial', sans-serif;">
        <button onclick="game.warpToAltitude()" style="padding: 10px 16px; font-size: 14px; font-weight: 600; color: #fff; background: #d4a03c; border: 1px solid rgba(0,0,0,0.15); border-bottom: 2px solid rgba(0,0,0,0.25); border-radius: 6px; cursor: pointer; letter-spacing: 0.3px; transition: all 0.15s ease;">üöÄ WARP</button>
        <button onclick="game.toggleWarp()" style="padding: 6px 12px; font-size: 12px; font-weight: 500; color: rgba(255,255,255,0.7); background: rgba(100,80,60,0.5); border: 1px solid rgba(0,0,0,0.2); border-radius: 4px; cursor: pointer;">CLOSE</button>
    </div>
    
    <!-- Warp Toggle Button (hidden by default, shown via Konami code) -->
    <button id="warpToggle" onclick="game.toggleWarp()" style="position: fixed; top: calc(env(safe-area-inset-top, 20px) + 20px); right: calc(env(safe-area-inset-right, 20px) + 20px); z-index: 10; padding: 10px 14px; font-size: 18px; background: rgba(212, 160, 60, 0.9); border: 1px solid rgba(0,0,0,0.2); border-bottom: 2px solid rgba(0,0,0,0.3); border-radius: 6px; cursor: pointer; display: none;">‚ö°</button>

    <!-- Multiplayer Leaderboard -->
    <div id="leaderboard">
        <div style="color: #ffd700; font-weight: bold; font-size: 24px; margin-bottom: 10px; text-align: center; ">üèÜ RACE</div>
        <div id="leaderboardList"></div>
    </div>

    <div class="power-bar" id="powerBar">
        <div class="power-bar-label">JUMP POWER</div>
        <div class="power-bar-container" id="powerBarContainer">
            <div class="power-fill" id="powerFill"></div>
            <div class="power-percentage" id="powerPercentage">50%</div>
        </div>
    </div>
    <div class="instruction" id="instruction">TAP POWER BAR ‚Ä¢ DRAG TO AIM ‚Ä¢ RELEASE TO JUMP</div>

    <!-- Start Screen -->
    <div class="screen active" id="startScreen">
        <div class="title">‚õ∞Ô∏è MOUNTAIN<br>CLIMBER</div>
        <div class="subtitle">Race to the Summit!</div>
        <button class="btn" onclick="game.startGame('solo')">üßó SOLO CLIMB</button>
        <button class="btn" onclick="game.startGame('multiplayer')" style="background: #6b8e23; border-color: rgba(0,0,0,0.2);">üë• MULTIPLAYER</button>
        <button class="btn" onclick="game.showStore()" style="background: #d4a03c; border-color: rgba(0,0,0,0.2);">üè™ STORE</button>
        <div class="coins-display">ü™ô <span id="totalCoins">0</span></div>
        <div style="position: absolute; bottom: 20px; color: rgba(255,255,255,0.3); font-size: 12px; font-weight: 500;">v1.0</div>
    </div>

    <!-- Store Screen -->
    <div class="screen" id="storeScreen">
        <div class="title">üè™ STORE</div>
        <div class="coins-display" style="margin-bottom: 20px;">ü™ô <span id="storeCoins">0</span></div>
        
        <div style="max-width: 90%; width: 600px; max-height: 60vh; overflow-y: auto; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(101, 67, 33, 0.5); border-radius: 10px; padding: 20px;">
            <!-- Tabs -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                <button class="btn" onclick="game.showStoreTab('skins')" id="skinsTab" style="padding: 10px 15px; font-size: 14px; min-width: 100px; border-radius: 6px;">üëï SKINS</button>
                <button class="btn" onclick="game.showStoreTab('powerups')" id="powerupsTab" style="padding: 10px 15px; font-size: 14px; min-width: 100px; border-radius: 6px;">‚ö° POWER-UPS</button>
                <button class="btn" onclick="game.showStoreTab('upgrades')" id="upgradesTab" style="padding: 10px 15px; font-size: 14px; min-width: 100px; border-radius: 6px;">‚¨ÜÔ∏è UPGRADES</button>
            </div>
            
            <!-- Store Content -->
            <div id="storeContent"></div>
        </div>
        
        <button class="btn" onclick="game.showStart()" style="margin-top: 20px;">‚Üê BACK</button>
    </div>

    <!-- Game Over Screen -->
    <div class="screen" id="gameOverScreen">
        <div class="title">‚õ∞Ô∏è TIME'S UP!</div>
        <div class="score-display">Height: <span id="finalHeight">0</span>m</div>
        <div class="coins-display">+<span id="earnedCoins">0</span> ü™ô</div>
        <button class="btn" onclick="startGame('solo')">CLIMB AGAIN</button>
        <button class="btn btn-secondary" onclick="showStart()">MENU</button>
    </div>

    <script>
        // Global game object (will be initialized when DOM loads)
        let game;
        
        // Global function wrappers for button onclick handlers
        function startGame(mode) {
            if (game && game.startGame) {
                game.startGame(mode);
            }
        }
        
        function showStart() {
            if (game && game.showStart) {
                game.showStart();
            }
        }
        
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Display dimensions (actual screen size in CSS pixels)
        let displayWidth = window.innerWidth;
        let displayHeight = window.innerHeight;

        // Perfect screen-filling canvas with aspect ratio handling
        function resizeCanvas() {
            // Fix for mobile browsers (address bar compensation)
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            
            // Get actual viewport dimensions
            displayWidth = window.innerWidth;
            displayHeight = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;
            
            // Set display size (CSS pixels)
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Set actual canvas size (accounting for DPI)
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            
            // Scale context to match DPI
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
            ctx.scale(dpr, dpr);
            
            // Update game ground level if it exists
            if (game && game.groundLevel !== undefined) {
                game.groundLevel = displayHeight - 100;
            }
            
            console.log(`Canvas resized: ${displayWidth}x${displayHeight} @ ${dpr}x DPI`);
        }
        
        // Render initial background scene (DEFINE EARLY so it's ready)
        function renderInitialBackground() {
            // Sky background
            const skyGradient = ctx.createLinearGradient(0, 0, 0, displayHeight);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(1, '#b0e0ff');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, displayWidth, displayHeight);
            
            // Draw a simple cliff preview
            const cliffCenterX = displayWidth / 2;
            const cliffWidth = displayWidth * 0.6;
            
            ctx.fillStyle = '#8b7355';
            ctx.strokeStyle = '#6b5335';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(cliffCenterX - cliffWidth/2, displayHeight);
            ctx.lineTo(cliffCenterX - cliffWidth/2 + 20, 0);
            ctx.lineTo(cliffCenterX + cliffWidth/2 - 20, 0);
            ctx.lineTo(cliffCenterX + cliffWidth/2, displayHeight);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Add some texture
            ctx.fillStyle = 'rgba(107, 83, 53, 0.3)';
            for (let y = 0; y < displayHeight; y += 100) {
                ctx.fillRect(cliffCenterX - cliffWidth/2, y, cliffWidth, 2);
            }
        }
        
        // Initial resize
        resizeCanvas();
        
        // CRITICAL: Render background IMMEDIATELY after canvas is sized
        renderInitialBackground();
        
        // Handle window resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                resizeCanvas();
                if (game && game.state === 'playing') {
                    updateRuler();
                }
            }, 100);
        });
        
        // Handle orientation change (mobile)
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                resizeCanvas();
                if (game && game.state === 'playing') {
                    updateRuler();
                }
            }, 200);
        });

        // Game state
        // Initialize the global game object
        game = {
            state: 'start', // start, playing, gameOver, victory
            mode: 'solo', // solo or multiplayer
            npcs: [], // NPC climbers in multiplayer
            timer: 30, // 30 seconds starting time for solo mode
            timerActive: false,
            countdown: 3, // Countdown for multiplayer start
            raceStarted: false, // Track if race has started
            raceFinished: false, // Track if race is over
            finishOrder: [], // Track order of finishers
            player: {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                radius: 15,
                currentHold: null,
                powerPercent: 50,
                lastJumpPowerPercent: 50, // Track power used in last jump for breakable holds
                aimMode: false,
                aimStartX: 0,
                aimStartY: 0,
                aimCurrentX: 0,
                aimCurrentY: 0,
                skin: 'default',
                grounded: false,
                snapping: false,
                snapProgress: 0,
                rotation: 0,
                targetRotation: 0,
                armAnimation: 0,
                legAnimation: 0,
                jumpBoost: 1.0, // Dynamic multiplier for unreachable situations
                reachableHolds: [],
                celebrating: false,
                celebrationTime: 0,
                name: 'YOU'
            },
            camera: {
                y: 0,
                targetY: 0
            },
            holds: [],
            particles: [],
            decorations: [], // shrubs, goats, etc.
            height: 0,
            maxHeight: 0,
            coins: 0,
            totalCoins: parseInt(localStorage.getItem('climberCoins') || '0'),
            difficulty: 1,
            holdSpacing: 150,
            lastHoldY: 0,
            continued: false,
            ownedSkins: JSON.parse(localStorage.getItem('ownedSkins') || '["default"]'),
            selectedSkin: localStorage.getItem('selectedSkin') || 'default',
            groundLevel: 0,
            lastMilestone: 0,
            milestones: [], // Will be calculated dynamically
            checkpointsCollected: [], // Track which checkpoints have been collected
            winThreshold: 500,
            completedRuns: 0,
            milestoneFlags: [],
            time: 0,
            activePowerUps: {
                coinMultiplier: 1,
                bonusTime: 0,
                revive: false,
                magnet: false,
                luckBoost: false,
                speedBoost: false
            },
            ownedUpgrades: JSON.parse(localStorage.getItem('ownedUpgrades') || '[]')
        };

        // Generate progressive milestones: 250m intervals (x3), 300m (x3), 350m (x3), 400m (x3), etc.
        function generateMilestones() {
            const milestones = [];
            let currentHeight = 0;
            let interval = 250; // Start at 250m
            
            for (let i = 0; i < 30; i++) { // Generate 30 milestones
                currentHeight += interval;
                milestones.push(currentHeight);
                interval += 100; // Increase by 100m each checkpoint
            }
            
            return milestones;
        }

        game.milestones = generateMilestones();
        console.log('Milestones:', game.milestones);

        // Skin definitions
        const skins = {
            // Starter Skins (Free-2500)
            default: { 
                name: 'Classic Climber', 
                cost: 0, 
                category: 'Starter',
                type: 'human',
                colors: { primary: '#ff6b6b', secondary: '#c23616', accent: '#2c3e50' },
                description: 'Your trusty climbing companion'
            },
            ninja: { 
                name: 'Shadow Ninja', 
                cost: 1000, 
                category: 'Starter',
                type: 'human',
                colors: { primary: '#2c3e50', secondary: '#000000', accent: '#e74c3c' },
                description: 'Silent and deadly'
            },
            astronaut: { 
                name: 'Space Explorer', 
                cost: 2500, 
                category: 'Starter',
                type: 'human',
                colors: { primary: '#ecf0f1', secondary: '#3498db', accent: '#e67e22' },
                description: 'One small step for climber...'
            },
            
            // Animal Collection (3000-6000)
            goat: { 
                name: 'Mountain Goat', 
                cost: 3000, 
                category: 'Animals',
                type: 'goat',
                colors: { primary: '#ecf0f1', secondary: '#95a5a6', accent: '#34495e' },
                description: 'Natural born climber'
            },
            cow: { 
                name: 'Holy Cow', 
                cost: 3500, 
                category: 'Animals',
                type: 'cow',
                colors: { primary: '#ffffff', secondary: '#000000', accent: '#e74c3c' },
                description: 'Udderly amazing'
            },
            monkey: { 
                name: 'Jungle Monkey', 
                cost: 4000, 
                category: 'Animals',
                type: 'monkey',
                colors: { primary: '#8b6914', secondary: '#d4a574', accent: '#ff69b4' },
                description: 'Swings into action'
            },
            panda: { 
                name: 'Kung Fu Panda', 
                cost: 4500, 
                category: 'Animals',
                type: 'panda',
                colors: { primary: '#ffffff', secondary: '#000000', accent: '#2ecc71' },
                description: 'The Dragon Warrior'
            },
            bear: { 
                name: 'Grizzly Bear', 
                cost: 5000, 
                category: 'Animals',
                type: 'bear',
                colors: { primary: '#8b6914', secondary: '#654321', accent: '#e74c3c' },
                description: 'Beary strong climber'
            },
            penguin: { 
                name: 'Arctic Penguin', 
                cost: 5500, 
                category: 'Animals',
                type: 'penguin',
                colors: { primary: '#000000', secondary: '#ffffff', accent: '#f39c12' },
                description: 'Waddles up mountains'
            },
            
            // Heroes Collection (6500-10000)
            spiderman: { 
                name: 'Web Slinger', 
                cost: 6500, 
                category: 'Heroes',
                type: 'hero',
                colors: { primary: '#e74c3c', secondary: '#3498db', accent: '#000000' },
                description: 'Friendly neighborhood climber'
            },
            batman: { 
                name: 'Dark Knight', 
                cost: 7500, 
                category: 'Heroes',
                type: 'hero',
                colors: { primary: '#2c3e50', secondary: '#34495e', accent: '#f39c12' },
                description: 'I am the night'
            },
            ironman: { 
                name: 'Iron Climber', 
                cost: 8500, 
                category: 'Heroes',
                type: 'hero',
                colors: { primary: '#e74c3c', secondary: '#f39c12', accent: '#ecf0f1' },
                description: 'Genius billionaire climber'
            },
            deadpool: { 
                name: 'Merc with Mouth', 
                cost: 10000, 
                category: 'Heroes',
                type: 'deadpool',
                colors: { primary: '#e74c3c', secondary: '#2c3e50', accent: '#ecf0f1' },
                description: 'Maximum effort climbing!'
            },
            
            // Villains Collection (11000-15000)
            darthvader: { 
                name: 'Dark Lord', 
                cost: 11000, 
                category: 'Villains',
                type: 'vader',
                colors: { primary: '#000000', secondary: '#2c3e50', accent: '#e74c3c' },
                description: 'I find your lack of climbing disturbing'
            },
            joker: { 
                name: 'Clown Prince', 
                cost: 12000, 
                category: 'Villains',
                type: 'villain',
                colors: { primary: '#9b59b6', secondary: '#2ecc71', accent: '#ecf0f1' },
                description: 'Why so serious about climbing?'
            },
            thanos: { 
                name: 'Mad Titan', 
                cost: 13000, 
                category: 'Villains',
                type: 'villain',
                colors: { primary: '#9b59b6', secondary: '#f39c12', accent: '#34495e' },
                description: 'Perfectly balanced climbing'
            },
            venom: { 
                name: 'Symbiote', 
                cost: 15000, 
                category: 'Villains',
                type: 'villain',
                colors: { primary: '#000000', secondary: '#ecf0f1', accent: '#e74c3c' },
                description: 'We are climber'
            },
            
            // Fantasy Collection (16000-20000)
            dragon: { 
                name: 'Fire Dragon', 
                cost: 16000, 
                category: 'Fantasy',
                type: 'dragon',
                colors: { primary: '#e74c3c', secondary: '#f39c12', accent: '#000000' },
                description: 'Breathes fire while climbing'
            },
            unicorn: { 
                name: 'Magical Unicorn', 
                cost: 17000, 
                category: 'Fantasy',
                type: 'unicorn',
                colors: { primary: '#ffffff', secondary: '#ff69b4', accent: '#9b59b6' },
                description: 'Believe in magic'
            },
            wizard: { 
                name: 'Grand Wizard', 
                cost: 18000, 
                category: 'Fantasy',
                type: 'wizard',
                colors: { primary: '#9b59b6', secondary: '#3498db', accent: '#f39c12' },
                description: 'You shall not fall!'
            },
            mermaid: { 
                name: 'Sea Climber', 
                cost: 20000, 
                category: 'Fantasy',
                type: 'mermaid',
                colors: { primary: '#3498db', secondary: '#1abc9c', accent: '#ff69b4' },
                description: 'Part of your world'
            },
            
            // Robot Collection (22000-28000)
            robot: { 
                name: 'Mega Bot', 
                cost: 22000, 
                category: 'Robots',
                type: 'robot',
                colors: { primary: '#95a5a6', secondary: '#34495e', accent: '#3498db' },
                description: 'Does not compute falling'
            },
            transformer: { 
                name: 'Auto-Climber', 
                cost: 24000, 
                category: 'Robots',
                type: 'robot',
                colors: { primary: '#e74c3c', secondary: '#3498db', accent: '#f39c12' },
                description: 'Climbers, roll out!'
            },
            terminator: { 
                name: 'Climber-800', 
                cost: 26000, 
                category: 'Robots',
                type: 'robot',
                colors: { primary: '#7f8c8d', secondary: '#e74c3c', accent: '#000000' },
                description: "I'll be back (at the top)"
            },
            walle: { 
                name: 'Waste Bot', 
                cost: 28000, 
                category: 'Robots',
                type: 'robot',
                colors: { primary: '#f39c12', secondary: '#95a5a6', accent: '#000000' },
                description: 'WALL-E climb!'
            },
            
            // Legendary Collection (30000-50000)
            goku: { 
                name: 'Super Saiyan', 
                cost: 30000, 
                category: 'Legendary',
                type: 'hero',
                colors: { primary: '#f39c12', secondary: '#3498db', accent: '#ecf0f1' },
                special: 'aura',
                description: 'OVER 9000 meters!'
            },
            sonic: { 
                name: 'Blue Blur', 
                cost: 35000, 
                category: 'Legendary',
                type: 'sonic',
                colors: { primary: '#3498db', secondary: '#e74c3c', accent: '#ecf0f1' },
                special: 'speed',
                description: 'Gotta climb fast!'
            },
            pikachu: { 
                name: 'Thunder Mouse', 
                cost: 40000, 
                category: 'Legendary',
                type: 'pokemon',
                colors: { primary: '#f1c40f', secondary: '#e74c3c', accent: '#000000' },
                special: 'electric',
                description: 'Pika-CLIMB!'
            },
            mario: { 
                name: 'Plumber Hero', 
                cost: 45000, 
                category: 'Legendary',
                type: 'mario',
                colors: { primary: '#e74c3c', secondary: '#3498db', accent: '#f39c12' },
                special: 'powerup',
                description: 'Wahoo! Let\'s-a-climb!'
            },
            rainbow: { 
                name: 'Rainbow Warrior', 
                cost: 50000, 
                category: 'Legendary',
                type: 'special',
                colors: { primary: '#ff0000', secondary: '#00ff00', accent: '#0000ff' },
                special: 'rainbow',
                description: 'Taste the rainbow'
            }
        };
        
        // Power-ups store (consumables)
        const powerUps = {
            doubleCoins: {
                name: '2x Coins Boost',
                description: 'üîÑ Single use: Next game earns double coins',
                icon: 'üí∞',
                cost: 500,
                type: 'consumable',
                effect: 'coinMultiplier',
                stackable: false
            },
            timeBoost: {
                name: 'Time Boost',
                description: 'üîÑ Single use: Next game starts with +30s bonus',
                icon: '‚è∞',
                cost: 300,
                type: 'consumable',
                effect: 'bonusTime',
                stackable: false
            },
            safetyNet: {
                name: 'Safety Net',
                description: 'üîÑ Single use: One free revival after falling',
                icon: 'üõ°Ô∏è',
                cost: 800,
                type: 'consumable',
                effect: 'revive',
                stackable: false
            },
            magnetCoins: {
                name: 'Coin Magnet',
                description: 'üîÑ Single use: Auto-collect all nearby coins',
                icon: 'üß≤',
                cost: 600,
                type: 'consumable',
                effect: 'magnet',
                stackable: false
            },
            luckyCharm: {
                name: 'Lucky Charm',
                description: 'üîÑ Single use: 35% ‚Üí 80% coin drop rate',
                icon: 'üçÄ',
                cost: 700,
                type: 'consumable',
                effect: 'luckBoost',
                stackable: false
            },
            speedBoost: {
                name: 'Quick Hands',
                description: 'üîÑ Single use: -50% jump cooldown',
                icon: '‚ö°',
                cost: 400,
                type: 'consumable',
                effect: 'speedBoost',
                stackable: false
            }
        };
        
        // Permanent upgrades store
        const upgrades = {
            jumpPower1: {
                name: 'Jump Power I',
                description: '‚ôæÔ∏è Permanent: +5% jump power',
                icon: 'üí™',
                cost: 2000,
                type: 'permanent',
                effect: 'jumpPower',
                value: 0.05,
                stackable: true,
                stackInfo: 'Stacks with II & III'
            },
            jumpPower2: {
                name: 'Jump Power II',
                description: '‚ôæÔ∏è Permanent: +10% jump power (total +15%)',
                icon: 'üí™üí™',
                cost: 5000,
                type: 'permanent',
                effect: 'jumpPower',
                value: 0.10,
                requires: 'jumpPower1',
                stackable: true,
                stackInfo: 'Requires I first'
            },
            jumpPower3: {
                name: 'Jump Power III',
                description: '‚ôæÔ∏è Permanent: +15% jump power (total +30%)',
                icon: 'üí™üí™üí™',
                cost: 10000,
                type: 'permanent',
                effect: 'jumpPower',
                value: 0.15,
                requires: 'jumpPower2',
                stackable: true,
                stackInfo: 'Requires II first'
            },
            timerBoost1: {
                name: 'Timer Extension I',
                description: '‚ôæÔ∏è Permanent: +5s starting time',
                icon: '‚è±Ô∏è',
                cost: 2000,
                type: 'permanent',
                effect: 'startTime',
                value: 5,
                stackable: true,
                stackInfo: 'Stacks with II & III'
            },
            timerBoost2: {
                name: 'Timer Extension II',
                description: '‚ôæÔ∏è Permanent: +10s starting time (total +15s)',
                icon: '‚è±Ô∏è‚è±Ô∏è',
                cost: 5000,
                type: 'permanent',
                effect: 'startTime',
                value: 10,
                requires: 'timerBoost1',
                stackable: true,
                stackInfo: 'Requires I first'
            },
            timerBoost3: {
                name: 'Timer Extension III',
                description: '‚ôæÔ∏è Permanent: +15s starting time (total +30s)',
                icon: '‚è±Ô∏è‚è±Ô∏è‚è±Ô∏è',
                cost: 10000,
                type: 'permanent',
                effect: 'startTime',
                value: 15,
                requires: 'timerBoost2',
                stackable: true,
                stackInfo: 'Requires II first'
            },
            coinBoost1: {
                name: 'Coin Luck I',
                description: '‚ôæÔ∏è Permanent: +10% coin drop rate',
                icon: 'ü™ô',
                cost: 3000,
                type: 'permanent',
                effect: 'coinRate',
                value: 0.10,
                stackable: true,
                stackInfo: 'Stacks with II'
            },
            coinBoost2: {
                name: 'Coin Luck II',
                description: '‚ôæÔ∏è Permanent: +20% coin drop rate (total +30%)',
                icon: 'ü™ôü™ô',
                cost: 7000,
                type: 'permanent',
                effect: 'coinRate',
                value: 0.20,
                requires: 'coinBoost1',
                stackable: true,
                stackInfo: 'Requires I first'
            },
            holdCooldown: {
                name: 'Grip Master',
                description: '‚ôæÔ∏è Permanent: -200ms hold cooldown',
                icon: 'üëê',
                cost: 8000,
                type: 'permanent',
                effect: 'cooldown',
                value: -200,
                stackable: false
            }
        };

        // Helper function to get cliff bounds at any Y position
        function getCliffBounds(y) {
            const baseCliffWidth = displayWidth * 0.6;
            const cliffCenterX = displayWidth / 2;
            
            // Smaller, more realistic variations for actual cliff face
            const leftVariation = Math.sin(y * 0.002) * 40 + 
                                 Math.sin(y * 0.008) * 20 + 
                                 Math.cos(y * 0.015) * 10;
            const rightVariation = Math.sin(y * 0.002 + Math.PI) * 40 + 
                                  Math.cos(y * 0.008 + 1) * 20 + 
                                  Math.sin(y * 0.015 + 2) * 10;
            
            return {
                left: cliffCenterX - baseCliffWidth / 2 + leftVariation,
                right: cliffCenterX + baseCliffWidth / 2 + rightVariation,
                center: cliffCenterX
            };
        }

        // Generate initial holds
        function generateHolds() {
            game.holds = [];
            game.decorations = [];
            game.milestoneFlags = [];
            game.groundLevel = displayHeight - 100;
            game.lastHoldY = game.groundLevel;
            game.lastMilestone = 0;
            
            // Starting hold at ground level
            game.holds.push({
                x: displayWidth / 2,
                y: game.groundLevel,
                width: 35,
                height: 20,
                type: 'normal',
                moving: false,
                visited: false,
                lastLeftTime: 0
            });

            // Generate holds upward
            for (let i = 0; i < 30; i++) {
                addHold();
            }
            
            // Generate decorations
            for (let i = 0; i < 20; i++) {
                addDecoration();
            }

            // Set player above first hold
            game.player.x = displayWidth / 2;
            game.player.y = game.groundLevel - 60;
            game.player.currentHold = game.holds[0];
            game.player.grounded = true;
            game.player.snapping = false;
            
            // Initialize camera to show player (only if game is playing, otherwise keep at 0 for start screen)
            if (game.state === 'playing' || game.state === 'victory') {
                game.camera.y = game.player.y - displayHeight * 0.6;
                game.camera.targetY = game.camera.y;
            } else {
                // Keep camera at 0 for start screen
                game.camera.y = 0;
                game.camera.targetY = 0;
            }
        }

        function addDecoration() {
            const y = game.lastHoldY - Math.random() * 300;
            const type = Math.random();
            
            let decoration;
            if (type < 0.6) {
                // Shrub
                decoration = {
                    type: 'shrub',
                    x: Math.random() * displayWidth,
                    y: y,
                    size: 20 + Math.random() * 30
                };
            } else if (type < 0.85) {
                // Small tree
                decoration = {
                    type: 'tree',
                    x: Math.random() * displayWidth,
                    y: y,
                    size: 40 + Math.random() * 40
                };
            } else {
                // Goat
                decoration = {
                    type: 'goat',
                    x: Math.random() * displayWidth,
                    y: y,
                    size: 25 + Math.random() * 15,
                    facingRight: Math.random() > 0.5
                };
            }
            
            game.decorations.push(decoration);
        }

        function addHold() {
            game.lastHoldY -= game.holdSpacing * (0.8 + Math.random() * 0.4);
            
            // Get cliff bounds at this Y position
            const bounds = getCliffBounds(game.lastHoldY);
            const cliffWidth = bounds.right - bounds.left;
            
            // Spawn hold within safe cliff bounds (with margin)
            const margin = 60;
            const minX = bounds.left + margin;
            const maxX = bounds.right - margin;
            const x = minX + Math.random() * (maxX - minX);
            
            // Increase difficulty over time
            const heightFactor = Math.abs(game.lastHoldY - game.groundLevel) / 1000;
            game.difficulty = 1 + heightFactor * 0.5;
            
            // Calculate height in meters
            const heightMeters = Math.abs(game.lastHoldY - game.groundLevel) / 10;
            
            let type = 'normal';
            let moving = false;
            let breakable = false;
            let width = 30 + Math.random() * 20;
            let height = 15 + Math.random() * 10;
            
            // Only allow moving holds after 150m
            if (heightMeters >= 150 && Math.random() < Math.min(0.3, heightFactor * 0.1)) {
                moving = true;
            }
            if (Math.random() < Math.min(0.2, heightFactor * 0.08)) {
                breakable = true;
            }
            if (Math.random() < Math.min(0.25, heightFactor * 0.1)) {
                width *= 0.7;
                height *= 0.7;
            }
            
            game.holds.push({
                x: x,
                y: game.lastHoldY,
                width: width,
                height: height,
                type: type,
                moving: moving,
                moveSpeed: moving ? (1 + Math.random() * 2) : 0,
                moveDir: Math.random() < 0.5 ? -1 : 1,
                moveRangeLeft: minX,
                moveRangeRight: maxX,
                breakable: breakable,
                broken: false,
                visited: false,
                lastLeftTime: 0 // Track when player last left this hold
            });
            
            // Add decoration near some holds
            if (Math.random() < 0.3) {
                addDecoration();
            }
        }

        // Physics
        function updatePlayer(dt) {
            // Don't update player during multiplayer countdown
            if (game.mode === 'multiplayer' && !game.raceStarted) {
                return;
            }
            
            // Update animations
            game.player.armAnimation += dt * 3;
            game.player.legAnimation += dt * 4;
            
            // Handle victory celebration
            if (game.player.celebrating) {
                game.player.celebrationTime += dt;
                // Jump celebration animation
                game.player.armAnimation += dt * 8;
                return;
            }
            
            // Smooth rotation
            game.player.rotation += (game.player.targetRotation - game.player.rotation) * 0.1;
            
            // Continuously analyze reachable holds when grounded
            if (game.player.grounded && game.state === 'playing') {
                analyzeReachableHolds();
            }
            
            // Handle smooth snapping
            if (game.player.snapping && game.player.currentHold) {
                game.player.snapProgress += dt * 8; // Snap speed
                
                if (game.player.snapProgress >= 1) {
                    // Snap complete
                    game.player.snapping = false;
                    game.player.grounded = true;
                    game.player.vx = 0;
                    game.player.vy = 0;
                    game.player.x = game.player.currentHold.x;
                    game.player.y = game.player.currentHold.y - game.player.currentHold.height / 2 - game.player.radius;
                    game.player.targetRotation = 0;
                    
                    // Award coin with only 20% chance (F2P monetization)
                    if (!game.player.currentHold.visited) {
                        game.player.currentHold.visited = true;
                        const dropChance = game.activePowerUps.luckBoost ? 0.8 : 0.35; // 35% base rate (was 20%), luck charm boosts to 80%
                        if (Math.random() < dropChance) {
                            game.coins += (game.activePowerUps.coinMultiplier * 2); // 2 coins per drop (was 1)
                            createCoinParticles(game.player.currentHold.x, game.player.currentHold.y);
                            vibrate(10);
                        }
                    }
                } else {
                    // Lerp to hold position
                    const targetX = game.player.currentHold.x;
                    const targetY = game.player.currentHold.y - game.player.currentHold.height / 2 - game.player.radius;
                    game.player.x += (targetX - game.player.x) * game.player.snapProgress;
                    game.player.y += (targetY - game.player.y) * game.player.snapProgress;
                }
                return;
            }
            
            // If grounded on a moving hold, move with it
            if (game.player.grounded && game.player.currentHold && game.player.currentHold.moving) {
                game.player.x = game.player.currentHold.x;
                game.player.y = game.player.currentHold.y - game.player.currentHold.height / 2 - game.player.radius;
            }
            
            // Normal physics when not snapping and not grounded
            if (!game.player.grounded) {
                // Apply gravity
                game.player.vy += 1500 * dt;
                
                // Update position
                game.player.x += game.player.vx * dt;
                game.player.y += game.player.vy * dt;
                
                // Rotate while airborne
                game.player.targetRotation = Math.atan2(game.player.vy, game.player.vx);
                
                // Calculate current velocity magnitude for impact detection
                const currentSpeed = Math.sqrt(game.player.vx * game.player.vx + game.player.vy * game.player.vy);
                const currentTime = Date.now();
                const COOLDOWN_MS = 500; // 500ms cooldown before can re-snap to same hold
                
                // Check collision with holds - ANY contact triggers snap or break
                for (let hold of game.holds) {
                    if (hold.broken) continue;
                    
                    // Check cooldown - skip if recently left this hold
                    const timeSinceLeft = currentTime - hold.lastLeftTime;
                    if (timeSinceLeft < COOLDOWN_MS) {
                        continue; // Skip this hold, still on cooldown
                    }
                    
                    const dx = game.player.x - hold.x;
                    const dy = game.player.y - hold.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if player is within collision radius (any contact)
                    const collisionDist = game.player.radius + Math.max(hold.width / 2, hold.height / 2);
                    
                    if (dist < collisionDist) {
                        // Calculate impact velocity - velocity component toward the hold
                        const holdDx = hold.x - game.player.x;
                        const holdDy = hold.y - game.player.y;
                        const holdDist = Math.sqrt(holdDx * holdDx + holdDy * holdDy);
                        
                        // Normalize direction to hold
                        const dirX = holdDx / holdDist;
                        const dirY = holdDy / holdDist;
                        
                        // Project velocity onto direction to hold (dot product)
                        const impactVelocity = game.player.vx * dirX + game.player.vy * dirY;
                        
                        // Only count impacts when moving toward the hold (positive dot product)
                        // Convert to m/s: 1 pixel = 0.01m, so multiply by 100 to get m/s
                        const impactSpeedMS = Math.abs(impactVelocity);
                        
                        // Check if impact is too hard (50 m/s threshold = 5000 pixels/s)
                        const breakThreshold = 5000; // 50 m/s in pixels/s
                        
                        if (impactSpeedMS > breakThreshold && impactVelocity > 0) {
                            // Impact too hard - break the hold immediately
                            hold.broken = true;
                            createBreakParticles(hold.x, hold.y);
                            createImpactEffect(hold.x, hold.y, impactSpeedMS);
                            vibrate(50);
                            
                            // Bounce player off slightly
                            game.player.vx *= 0.3;
                            game.player.vy *= 0.3;
                            
                            continue; // Don't snap to this hold, keep falling
                        }
                        
                        // Normal landing - start smooth snap
                        game.player.currentHold = hold;
                        game.player.snapping = true;
                        game.player.snapProgress = 0;
                        
                        // Break if breakable AND jumped with >80% power
                        if (hold.breakable && game.player.lastJumpPowerPercent > 80) {
                            setTimeout(() => {
                                hold.broken = true;
                                createBreakParticles(hold.x, hold.y);
                                if (game.player.currentHold === hold) {
                                    game.player.grounded = false;
                                    game.player.snapping = false;
                                    game.player.vy = 100; // Small downward velocity
                                }
                            }, 300);
                        }
                        
                        break;
                    }
                }
            }
            
            // Check for fall to ground
            if (game.player.y > game.groundLevel + 50) {
                gameOver();
            }
            
            // Update height
            const newHeight = Math.max(0, Math.floor((game.groundLevel - game.player.y) / 10));
            
            // Check for milestones/checkpoints
            for (let milestone of game.milestones) {
                if (newHeight >= milestone && !game.checkpointsCollected.includes(milestone)) {
                    game.checkpointsCollected.push(milestone);
                    game.lastMilestone = milestone;
                    addMilestoneFlag(milestone);
                    game.coins += Math.floor(milestone / 50); // milestone/50 for better progression
                    
                    // Add progressively more time for each checkpoint
                    if (game.mode === 'solo' && game.timerActive) {
                        const checkpointNumber = game.checkpointsCollected.length;
                        const timeBonus = 20 + ((checkpointNumber - 1) * 3); // 20s, 23s, 26s, 29s, 32s...
                        game.timer += timeBonus;
                        showTimeBonus(timeBonus);
                    }
                    
                    vibrate(50);
                    break;
                }
            }
            
            game.height = newHeight;
            game.maxHeight = Math.max(game.maxHeight, game.height);
            
            // Check if player reached 1000m in multiplayer
            if (game.mode === 'multiplayer' && game.height >= 1000 && !game.raceFinished) {
                game.finishOrder.push('YOU');
                checkRaceFinish();
            }
            
            // Update camera
            game.camera.targetY = game.player.y - displayHeight * 0.6;
            game.camera.y += (game.camera.targetY - game.camera.y) * 0.1;
            
            // Generate more holds
            if (-game.lastHoldY < -game.camera.y + displayHeight * 2) {
                addHold();
            }
            
            // Update moving holds - keep within cliff bounds
            for (let hold of game.holds) {
                if (hold.moving && !hold.broken) {
                    hold.x += hold.moveSpeed * hold.moveDir;
                    
                    // Use the hold's stored movement range
                    if (hold.x < hold.moveRangeLeft || hold.x > hold.moveRangeRight) {
                        hold.moveDir *= -1;
                        // Clamp to bounds
                        hold.x = Math.max(hold.moveRangeLeft, Math.min(hold.moveRangeRight, hold.x));
                    }
                }
            }
        }

        function updateParticles(dt) {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.life -= dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 500 * dt;
                
                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }
        }

        function createCoinParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                game.particles.push({
                    x: x,
                    y: y - 40,
                    vx: Math.cos(angle) * 100,
                    vy: Math.sin(angle) * 100 - 100,
                    life: 0.5,
                    color: '#ffd700'
                });
            }
        }

        function createJumpParticles(x, y, isBoosted = false) {
            const particleCount = isBoosted ? 12 : 6;
            const particleColor = isBoosted ? '#ffd700' : '#d4a78a';
            
            for (let i = 0; i < particleCount; i++) {
                game.particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * (isBoosted ? 200 : 100),
                    vy: Math.random() * (isBoosted ? 150 : 100),
                    life: isBoosted ? 0.5 : 0.3,
                    color: particleColor
                });
            }
        }

        function createBreakParticles(x, y) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 * i) / 12;
                const speed = 100 + Math.random() * 150;
                game.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 100,
                    life: 0.6,
                    color: '#8b7355'
                });
            }
        }

        function createImpactEffect(x, y, speed) {
            // Create shockwave ring effect
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const particleSpeed = 150 + Math.random() * 100;
                game.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * particleSpeed,
                    vy: Math.sin(angle) * particleSpeed,
                    life: 0.4,
                    color: '#ff6b6b'
                });
            }
            
            // Add extra dust particles
            for (let i = 0; i < 8; i++) {
                game.particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 200,
                    vy: -Math.random() * 200,
                    life: 0.5,
                    color: '#d4a78a'
                });
            }
        }

        function showMilestone(height) {
            const milestoneEl = document.createElement('div');
            milestoneEl.className = 'milestone-popup';
            milestoneEl.textContent = `üèîÔ∏è ${height}m MILESTONE!`;
            document.body.appendChild(milestoneEl);
            
            setTimeout(() => {
                milestoneEl.remove();
            }, 2000);
        }

        function addMilestoneFlag(height) {
            const flagY = game.groundLevel - (height * 10);
            game.milestoneFlags.push({
                height: height,
                y: flagY,
                leftSide: Math.random() > 0.5
            });
        }

        function winGame(position = 1) {
            game.state = 'victory';
            game.player.celebrating = true;
            game.player.celebrationTime = 0;
            
            vibrate(100);
            
            // Determine result message based on position
            let resultMessage = 'üèÜ VICTORY!';
            const medals = ['ü•á', 'ü•à', 'ü•â', '4Ô∏è‚É£'];
            const placeNames = ['FIRST PLACE!', 'SECOND PLACE!', 'THIRD PLACE!', '4TH PLACE'];
            const messages = ['YOU WIN!', 'Nice climb!', 'Good effort!', 'Keep climbing!'];
            
            if (game.mode === 'multiplayer') {
                const medal = medals[position - 1] || 'üèÅ';
                const place = placeNames[position - 1] || `${position}TH PLACE`;
                const msg = messages[position - 1] || 'Nice try!';
                resultMessage = `${medal} ${place}\n${msg}`;
            }
            
            // Show victory after animation
            setTimeout(() => {
                game.totalCoins += game.coins;
                if (position === 1) {
                    game.totalCoins += 100; // Victory bonus
                }
                localStorage.setItem('climberCoins', game.totalCoins);
                game.completedRuns++;
                
                const oldThreshold = game.winThreshold;
                
                // Calculate next win threshold
                if (game.completedRuns === 1) {
                    game.winThreshold = 750;
                } else if (game.completedRuns === 2) {
                    game.winThreshold = 1000;
                } else {
                    game.winThreshold = 1000 + (game.completedRuns - 2) * 250;
                }
                
                alert(`${resultMessage}\n\nHeight: ${oldThreshold}m\n+${game.coins + oldThreshold} coins\n\nNext challenge: ${game.winThreshold}m`);
                
                // Reset game state but keep threshold increased
                resetGameForNextChallenge();
            }, 4000);
        }

        function resetGameForNextChallenge() {
            // Reset player position
            game.player.x = displayWidth / 2;
            game.player.y = game.groundLevel - 60;
            game.player.vx = 0;
            game.player.vy = 0;
            game.player.grounded = true;
            game.player.snapping = false;
            game.player.celebrating = false;
            game.player.celebrationTime = 0;
            game.player.rotation = 0;
            game.player.targetRotation = 0;
            game.player.jumpBoost = 1.0;
            game.player.reachableHolds = [];
            
            // Reset game data
            game.height = 0;
            game.maxHeight = 0;
            game.coins = 0;
            game.lastMilestone = 0;
            game.milestoneFlags = [];
            game.checkpointsCollected = [];
            
            // Reset timer for solo mode
            if (game.mode === 'solo') {
                game.timer = 30;
                game.timerActive = true;
            }
            
            // Regenerate holds
            generateHolds();
            
            // Reset camera
            game.camera.y = 0;
            game.camera.targetY = 0;
            
            // Reset state
            game.state = 'playing';
        }

        function updateLeaderboard() {
            if (game.mode !== 'multiplayer') {
                document.getElementById('leaderboard').style.display = 'none';
                return;
            }
            
            document.getElementById('leaderboard').style.display = 'block';
            
            // Collect all players
            const allPlayers = [
                { name: game.player.name, height: game.height, color: skins[game.player.skin]?.color || '#ff6b6b', isPlayer: true },
                ...game.npcs.map(npc => ({ name: npc.name, height: npc.height, color: npc.color, isPlayer: false }))
            ];
            
            // Sort by height descending
            allPlayers.sort((a, b) => b.height - a.height);
            
            // Build leaderboard HTML
            let html = '';
            for (let i = 0; i < allPlayers.length; i++) {
                const p = allPlayers[i];
                const position = i + 1;
                const medal = position === 1 ? 'ü•á' : position === 2 ? 'ü•à' : position === 3 ? 'ü•â' : `${position}.`;
                const highlight = p.isPlayer ? 'background: rgba(255, 215, 0, 0.2); border-left: 3px solid #ffd700;' : '';
                const fontWeight = p.isPlayer ? 'bold' : 'normal';
                
                html += `
                    <div style="padding: 6px 8px; margin: 4px 0; border-radius: 8px; ${highlight} display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #fff;  font-weight: ${fontWeight};">
                            ${medal} <span style="color: ${p.color};">${p.name}</span>
                        </span>
                        <span style="color: #d4a78a; font-weight: bold; ">${p.height}m</span>
                    </div>
                `;
            }
            
            document.getElementById('leaderboardList').innerHTML = html;
        }

        function updateRuler() {
            const rulerBg = document.getElementById('rulerBg');
            if (!rulerBg) return; // Element was removed, skip ruler updates
            
            rulerBg.innerHTML = '';
            
            // Show simple height markers with checkpoints (endless climb)
            const markerInterval = 100;
            const displayHeight = Math.max(game.maxHeight + 300, 1000);
            
            for (let h = 0; h <= displayHeight; h += markerInterval) {
                const marker = document.createElement('div');
                marker.className = 'ruler-marker';
                
                const percent = (h / displayHeight) * 100;
                marker.style.bottom = percent + '%';
                
                // Highlight achieved heights
                if (h <= game.height) {
                    marker.style.background = '#d4a78a';
                    marker.style.opacity = '1';
                } else {
                    marker.style.opacity = '0.4';
                }
                
                // Show checkpoint markers
                if (game.milestones.includes(h)) {
                    const collected = game.checkpointsCollected.includes(h);
                    const text = document.createElement('div');
                    text.className = 'ruler-text';
                    text.textContent = collected ? '‚úì ' + h + 'm' : '‚è±Ô∏è ' + h + 'm';
                    text.style.bottom = `calc(${percent}% - 6px)`;
                    text.style.color = collected ? '#4ecdc4' : '#ffd700';
                    text.style.fontWeight = 'bold';
                    marker.appendChild(text);
                } else if (h % 500 === 0 && h > 0) {
                    const text = document.createElement('div');
                    text.className = 'ruler-text';
                    text.textContent = h + 'm';
                    text.style.bottom = `calc(${percent}% - 6px)`;
                    marker.appendChild(text);
                }
                
                rulerBg.appendChild(marker);
            }
            
            // Current height indicator
            const currentPercent = (game.height / displayHeight) * 100;
            const currentIndicator = document.createElement('div');
            currentIndicator.style.position = 'absolute';
            currentIndicator.style.bottom = currentPercent + '%';
            currentIndicator.style.left = '50%';
            currentIndicator.style.transform = 'translateX(-50%)';
            currentIndicator.style.width = '100%';
            currentIndicator.style.height = '3px';
            currentIndicator.style.background = '#ff6b6b';
            currentIndicator.style.boxShadow = '0 0 10px rgba(255, 107, 107, 0.8)';
            rulerBg.appendChild(currentIndicator);
        }
        
        // Character drawing function
        function drawCharacter(ctx, skin, player) {
            const r = player.radius;
            const colors = skin.colors;
            
            // Draw based on character type
            switch(skin.type) {
                case 'deadpool':
                    // Red suit
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Black accents
                    ctx.fillStyle = colors.secondary;
                    ctx.fillRect(-r*0.3, -r*0.2, r*0.6, r*0.1);
                    // Eye patches (white)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(-r*0.3, -r*0.2, r*0.25, r*0.3, -0.2, 0, Math.PI * 2);
                    ctx.ellipse(r*0.3, -r*0.2, r*0.25, r*0.3, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Black eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.3, -r*0.15, r*0.15, 0, Math.PI * 2);
                    ctx.arc(r*0.3, -r*0.15, r*0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // Pouches
                    ctx.fillStyle = colors.secondary;
                    ctx.fillRect(-r*0.6, r*0.3, r*0.4, r*0.3);
                    ctx.fillRect(r*0.2, r*0.3, r*0.4, r*0.3);
                    break;
                    
                case 'vader':
                    // Black helmet
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Helmet dome
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(0, -r*0.3, r*0.9, 0, Math.PI, true);
                    ctx.fill();
                    // Face mask
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-r*0.6, -r*0.1, r*1.2, r*0.8);
                    // Eyes
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(-r*0.4, -r*0.05, r*0.3, r*0.15);
                    ctx.fillRect(r*0.1, -r*0.05, r*0.3, r*0.15);
                    // Respirator
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-r*0.3, r*0.3, r*0.6, r*0.4);
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.2, r*0.4);
                    ctx.lineTo(-r*0.2, r*0.6);
                    ctx.moveTo(0, r*0.4);
                    ctx.lineTo(0, r*0.6);
                    ctx.moveTo(r*0.2, r*0.4);
                    ctx.lineTo(r*0.2, r*0.6);
                    ctx.stroke();
                    break;
                    
                case 'goat':
                    // White/gray fur body
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.6, -r*0.5);
                    ctx.quadraticCurveTo(-r*0.8, -r*0.9, -r*0.5, -r*1.1);
                    ctx.quadraticCurveTo(-r*0.5, -r*0.7, -r*0.6, -r*0.5);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r*0.6, -r*0.5);
                    ctx.quadraticCurveTo(r*0.8, -r*0.9, r*0.5, -r*1.1);
                    ctx.quadraticCurveTo(r*0.5, -r*0.7, r*0.6, -r*0.5);
                    ctx.fill();
                    // Face details
                    ctx.fillStyle = colors.secondary;
                    ctx.fillRect(-r*0.5, -r*0.2, r, r*0.6);
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(-r*0.3, -r*0.1, r*0.15, r*0.25);
                    ctx.fillRect(r*0.15, -r*0.1, r*0.15, r*0.25);
                    // Beard
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.4, r*0.4);
                    ctx.lineTo(0, r*0.9);
                    ctx.lineTo(r*0.4, r*0.4);
                    ctx.fill();
                    break;
                    
                case 'cow':
                    // White body with black spots
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Black spots
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(-r*0.4, -r*0.3, r*0.3, 0, Math.PI * 2);
                    ctx.arc(r*0.3, r*0.2, r*0.4, 0, Math.PI * 2);
                    ctx.arc(-r*0.2, r*0.5, r*0.25, 0, Math.PI * 2);
                    ctx.fill();
                    // Snout
                    ctx.fillStyle = '#ffcccc';
                    ctx.fillRect(-r*0.4, r*0.3, r*0.8, r*0.4);
                    // Nostrils
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.2, r*0.5, r*0.08, 0, Math.PI * 2);
                    ctx.arc(r*0.2, r*0.5, r*0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.ellipse(-r*0.8, -r*0.3, r*0.25, r*0.4, -0.4, 0, Math.PI * 2);
                    ctx.ellipse(r*0.8, -r*0.3, r*0.25, r*0.4, 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.3, 0, r*0.12, 0, Math.PI * 2);
                    ctx.arc(r*0.3, 0, r*0.12, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'panda':
                    // White face
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Black ears
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(-r*0.7, -r*0.5, r*0.4, 0, Math.PI * 2);
                    ctx.arc(r*0.7, -r*0.5, r*0.4, 0, Math.PI * 2);
                    ctx.fill();
                    // Black eye patches
                    ctx.beginPath();
                    ctx.ellipse(-r*0.35, -r*0.1, r*0.3, r*0.35, -0.2, 0, Math.PI * 2);
                    ctx.ellipse(r*0.35, -r*0.1, r*0.3, r*0.35, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // White eyes
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-r*0.3, -r*0.1, r*0.15, 0, Math.PI * 2);
                    ctx.arc(r*0.3, -r*0.1, r*0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // Black pupils
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.3, -r*0.1, r*0.08, 0, Math.PI * 2);
                    ctx.arc(r*0.3, -r*0.1, r*0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.beginPath();
                    ctx.arc(0, r*0.2, r*0.12, 0, Math.PI * 2);
                    ctx.fill();
                    // Bamboo stick
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(r*0.5, -r*0.3, r*0.15, r*1.2);
                    ctx.strokeStyle = '#2a5520';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(r*0.5, -r*0.1);
                    ctx.lineTo(r*0.65, -r*0.1);
                    ctx.moveTo(r*0.5, r*0.3);
                    ctx.lineTo(r*0.65, r*0.3);
                    ctx.stroke();
                    break;
                    
                case 'penguin':
                    // Black body
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // White belly
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.ellipse(0, r*0.2, r*0.6, r*0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes (white circles)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-r*0.25, -r*0.3, r*0.2, 0, Math.PI * 2);
                    ctx.arc(r*0.25, -r*0.3, r*0.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Pupils
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.25, -r*0.25, r*0.1, 0, Math.PI * 2);
                    ctx.arc(r*0.25, -r*0.25, r*0.1, 0, Math.PI * 2);
                    ctx.fill();
                    // Orange beak
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-r*0.15, r*0.15);
                    ctx.lineTo(r*0.15, r*0.15);
                    ctx.closePath();
                    ctx.fill();
                    // Flippers
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.ellipse(-r*0.9, r*0.2, r*0.3, r*0.5, -0.5, 0, Math.PI * 2);
                    ctx.ellipse(r*0.9, r*0.2, r*0.3, r*0.5, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case 'hero': // Spiderman, Batman, Ironman, Goku
                    if (skin.name.includes('Web')) {
                        // Spiderman - red with web pattern
                        ctx.fillStyle = colors.primary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        // Web pattern
                        ctx.strokeStyle = colors.secondary;
                        ctx.lineWidth = 1.5;
                        for(let i = 0; i < 8; i++) {
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            const angle = (Math.PI * 2 / 8) * i;
                            ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            ctx.stroke();
                        }
                        for(let rad = r*0.3; rad < r; rad += r*0.2) {
                            ctx.beginPath();
                            ctx.arc(0, 0, rad, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        // White eyes
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.ellipse(-r*0.3, -r*0.2, r*0.2, r*0.35, -0.3, 0, Math.PI * 2);
                        ctx.ellipse(r*0.3, -r*0.2, r*0.2, r*0.35, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (skin.name.includes('Dark')) {
                        // Batman - black with cowl
                        ctx.fillStyle = colors.primary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        // Bat ears
                        ctx.beginPath();
                        ctx.moveTo(-r*0.5, -r*0.7);
                        ctx.lineTo(-r*0.3, -r*1.2);
                        ctx.lineTo(-r*0.2, -r*0.7);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(r*0.5, -r*0.7);
                        ctx.lineTo(r*0.3, -r*1.2);
                        ctx.lineTo(r*0.2, -r*0.7);
                        ctx.fill();
                        // Cape
                        ctx.fillStyle = colors.secondary;
                        ctx.beginPath();
                        ctx.moveTo(-r*0.8, 0);
                        ctx.lineTo(-r*0.6, r*0.9);
                        ctx.lineTo(r*0.6, r*0.9);
                        ctx.lineTo(r*0.8, 0);
                        ctx.fill();
                        // Bat symbol
                        ctx.fillStyle = colors.accent;
                        ctx.beginPath();
                        ctx.ellipse(0, r*0.3, r*0.4, r*0.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // White eyes
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(-r*0.35, -r*0.2, r*0.2, r*0.12);
                        ctx.fillRect(r*0.15, -r*0.2, r*0.2, r*0.12);
                    } else if (skin.name.includes('Iron')) {
                        // Iron Man - red/gold armor
                        ctx.fillStyle = colors.primary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        // Face plate
                        ctx.fillStyle = colors.accent;
                        ctx.fillRect(-r*0.6, -r*0.4, r*1.2, r*0.5);
                        // Eyes
                        ctx.fillStyle = colors.secondary;
                        ctx.fillRect(-r*0.4, -r*0.25, r*0.25, r*0.15);
                        ctx.fillRect(r*0.15, -r*0.25, r*0.25, r*0.15);
                        // Arc reactor
                        ctx.fillStyle = colors.secondary;
                        ctx.beginPath();
                        ctx.arc(0, r*0.4, r*0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, r*0.4, r*0.2, 0, Math.PI * 2);
                        ctx.stroke();
                        // Armor panels
                        ctx.strokeStyle = colors.accent;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-r*0.7, 0);
                        ctx.lineTo(-r*0.3, 0);
                        ctx.moveTo(r*0.3, 0);
                        ctx.lineTo(r*0.7, 0);
                        ctx.stroke();
                    } else {
                        // Goku - orange gi with blue details
                        ctx.fillStyle = colors.primary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        // Gi details
                        ctx.fillStyle = colors.secondary;
                        ctx.fillRect(-r*0.7, -r*0.1, r*1.4, r*0.2);
                        ctx.fillRect(-r*0.3, r*0.2, r*0.6, r*0.5);
                        // Hair (spiky)
                        ctx.fillStyle = '#000';
                        for(let i = 0; i < 5; i++) {
                            const x = -r*0.6 + (i * r*0.3);
                            ctx.beginPath();
                            ctx.moveTo(x, -r*0.5);
                            ctx.lineTo(x, -r*1.1);
                            ctx.lineTo(x + r*0.15, -r*0.5);
                            ctx.fill();
                        }
                        // Eyes
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-r*0.2, -r*0.1, r*0.08, 0, Math.PI * 2);
                        ctx.arc(r*0.2, -r*0.1, r*0.08, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                
                case 'villain': // Joker, Thanos, Venom
                    if (skin.name.includes('Clown')) {
                        // Joker - purple suit, green hair
                        ctx.fillStyle = colors.primary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        // Green hair
                        ctx.fillStyle = colors.secondary;
                        ctx.beginPath();
                        ctx.arc(0, -r*0.5, r*0.8, Math.PI, 0, true);
                        ctx.fill();
                        // White face
                        ctx.fillStyle = colors.accent;
                        ctx.beginPath();
                        ctx.arc(0, 0, r*0.7, 0, Math.PI * 2);
                        ctx.fill();
                        // Red smile
                        ctx.strokeStyle = '#e74c3c';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, r*0.1, r*0.4, 0.2, Math.PI - 0.2);
                        ctx.stroke();
                        // Eyes
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-r*0.25, -r*0.15, r*0.08, 0, Math.PI * 2);
                        ctx.arc(r*0.25, -r*0.15, r*0.08, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (skin.name.includes('Mad')) {
                        // Thanos - purple with golden gauntlet
                        ctx.fillStyle = colors.primary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        // Helmet ridges
                        ctx.strokeStyle = colors.secondary;
                        ctx.lineWidth = 3;
                        for(let i = -1; i <= 1; i++) {
                            ctx.beginPath();
                            ctx.arc(i * r*0.3, -r*0.4, r*0.5, Math.PI * 1.2, Math.PI * 1.8);
                            ctx.stroke();
                        }
                        // Eyes (small, intense)
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(-r*0.3, -r*0.1, r*0.15, r*0.08);
                        ctx.fillRect(r*0.15, -r*0.1, r*0.15, r*0.08);
                        // Gauntlet (gold with gems)
                        ctx.fillStyle = colors.accent;
                        ctx.fillRect(r*0.5, 0, r*0.4, r*0.6);
                        const gemColors = ['#9b59b6', '#3498db', '#e74c3c', '#f39c12', '#2ecc71', '#e67e22'];
                        for(let i = 0; i < 6; i++) {
                            ctx.fillStyle = gemColors[i];
                            const y = r*0.1 + (i * r*0.15);
                            ctx.beginPath();
                            ctx.arc(r*0.7, y, r*0.08, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else {
                        // Venom - black with white spider and eyes
                        ctx.fillStyle = colors.primary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        // White spider symbol
                        ctx.fillStyle = colors.secondary;
                        ctx.beginPath();
                        ctx.arc(0, 0, r*0.3, 0, Math.PI * 2);
                        ctx.fill();
                        for(let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            ctx.fillRect(Math.cos(angle) * r*0.3 - 2, Math.sin(angle) * r*0.3 - 2, r*0.5, 4);
                        }
                        // Large white eyes
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.ellipse(-r*0.3, -r*0.2, r*0.3, r*0.4, -0.3, 0, Math.PI * 2);
                        ctx.ellipse(r*0.3, -r*0.2, r*0.3, r*0.4, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        // Teeth
                        ctx.fillStyle = '#fff';
                        for(let i = -3; i <= 3; i++) {
                            ctx.fillRect(i * r*0.15, r*0.3, r*0.1, r*0.2);
                        }
                    }
                    break;
                
                case 'dragon':
                    // Fire dragon - red/orange with wings and horns
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.moveTo(-r, 0);
                    ctx.lineTo(-r*1.5, -r*0.5);
                    ctx.lineTo(-r*1.3, r*0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r, 0);
                    ctx.lineTo(r*1.5, -r*0.5);
                    ctx.lineTo(r*1.3, r*0.5);
                    ctx.closePath();
                    ctx.fill();
                    // Horns
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.5, -r*0.6);
                    ctx.lineTo(-r*0.4, -r*1.2);
                    ctx.lineTo(-r*0.3, -r*0.6);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r*0.5, -r*0.6);
                    ctx.lineTo(r*0.4, -r*1.2);
                    ctx.lineTo(r*0.3, -r*0.6);
                    ctx.fill();
                    // Eyes (fierce)
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(-r*0.25, -r*0.2, r*0.15, 0, Math.PI * 2);
                    ctx.arc(r*0.25, -r*0.2, r*0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.fillRect(-r*0.27, -r*0.2, r*0.04, r*0.15);
                    ctx.fillRect(r*0.23, -r*0.2, r*0.04, r*0.15);
                    // Snout with fire
                    ctx.strokeStyle = colors.accent;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, r*0.3, r*0.3, 0, Math.PI);
                    ctx.stroke();
                    break;
                
                case 'unicorn':
                    // Magical unicorn - white with rainbow details
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Horn (rainbow)
                    const rainbowGrad = ctx.createLinearGradient(0, -r*1.3, 0, -r*0.6);
                    rainbowGrad.addColorStop(0, '#ff0000');
                    rainbowGrad.addColorStop(0.5, '#ffff00');
                    rainbowGrad.addColorStop(1, '#00ffff');
                    ctx.fillStyle = rainbowGrad;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.1, -r*0.6);
                    ctx.lineTo(0, -r*1.3);
                    ctx.lineTo(r*0.1, -r*0.6);
                    ctx.closePath();
                    ctx.fill();
                    // Mane (rainbow)
                    for(let i = 0; i < 5; i++) {
                        const colors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff'];
                        ctx.fillStyle = colors[i];
                        ctx.beginPath();
                        ctx.arc(-r*0.7 + i*0.05*r, -r*0.3, r*0.15, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Eyes (sparkly)
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.arc(-r*0.25, -r*0.1, r*0.12, 0, Math.PI * 2);
                    ctx.arc(r*0.25, -r*0.1, r*0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-r*0.22, -r*0.12, r*0.05, 0, Math.PI * 2);
                    ctx.arc(r*0.28, -r*0.12, r*0.05, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                
                case 'robot':
                    // Robot - metallic with antennas and panels
                    ctx.fillStyle = colors.primary;
                    ctx.fillRect(-r*0.8, -r*0.8, r*1.6, r*1.6);
                    // Panel lines
                    ctx.strokeStyle = colors.accent;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-r*0.8, -r*0.8, r*1.6, r*1.6);
                    ctx.beginPath();
                    ctx.moveTo(-r*0.8, 0);
                    ctx.lineTo(r*0.8, 0);
                    ctx.moveTo(0, -r*0.8);
                    ctx.lineTo(0, r*0.8);
                    ctx.stroke();
                    // Antenna
                    ctx.fillStyle = colors.secondary;
                    ctx.fillRect(-r*0.1, -r*1.2, r*0.2, r*0.4);
                    ctx.beginPath();
                    ctx.arc(0, -r*1.2, r*0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes (LED)
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(-r*0.5, -r*0.3, r*0.3, r*0.15);
                    ctx.fillRect(r*0.2, -r*0.3, r*0.3, r*0.15);
                    // Mouth (speaker grille)
                    ctx.strokeStyle = colors.secondary;
                    for(let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-r*0.4, r*0.2 + i*0.08*r);
                        ctx.lineTo(r*0.4, r*0.2 + i*0.08*r);
                        ctx.stroke();
                    }
                    break;
                
                case 'sonic':
                    // Sonic - blue with red shoes
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Spiky head
                    for(let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i - Math.PI/2;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * r*0.7, Math.sin(angle) * r*0.7);
                        ctx.lineTo(Math.cos(angle) * r*1.4, Math.sin(angle) * r*1.4);
                        ctx.lineTo(Math.cos(angle + 0.5) * r*0.7, Math.sin(angle + 0.5) * r*0.7);
                        ctx.fill();
                    }
                    // Peach muzzle
                    ctx.fillStyle = '#ffd7a8';
                    ctx.beginPath();
                    ctx.arc(0, r*0.1, r*0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes (connected)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.ellipse(-r*0.25, -r*0.2, r*0.25, r*0.3, 0, 0, Math.PI * 2);
                    ctx.ellipse(r*0.25, -r*0.2, r*0.25, r*0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Pupils
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.25, -r*0.15, r*0.12, 0, Math.PI * 2);
                    ctx.arc(r*0.25, -r*0.15, r*0.12, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, r*0.15, r*0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Red shoes indicator
                    ctx.fillStyle = colors.secondary;
                    ctx.fillRect(-r*0.4, r*0.7, r*0.35, r*0.25);
                    ctx.fillRect(r*0.05, r*0.7, r*0.35, r*0.25);
                    break;
                
                case 'pokemon':
                    // Pikachu
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears (black tips)
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.5, -r*0.5);
                    ctx.lineTo(-r*0.3, -r*1.2);
                    ctx.lineTo(-r*0.2, -r*0.6);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r*0.5, -r*0.5);
                    ctx.lineTo(r*0.3, -r*1.2);
                    ctx.lineTo(r*0.2, -r*0.6);
                    ctx.fill();
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.moveTo(-r*0.35, -r*0.9);
                    ctx.lineTo(-r*0.3, -r*1.2);
                    ctx.lineTo(-r*0.25, -r*0.9);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r*0.35, -r*0.9);
                    ctx.lineTo(r*0.3, -r*1.2);
                    ctx.lineTo(r*0.25, -r*0.9);
                    ctx.fill();
                    // Red cheeks
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(-r*0.5, r*0.1, r*0.15, 0, Math.PI * 2);
                    ctx.arc(r*0.5, r*0.1, r*0.15, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.25, -r*0.15, r*0.08, 0, Math.PI * 2);
                    ctx.arc(r*0.25, -r*0.15, r*0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Lightning bolt tail
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.moveTo(r*0.6, r*0.3);
                    ctx.lineTo(r*1.0, r*0.5);
                    ctx.lineTo(r*0.8, r*0.7);
                    ctx.lineTo(r*1.1, r*0.9);
                    ctx.lineTo(r*0.7, r*0.75);
                    ctx.lineTo(r*0.85, r*0.55);
                    ctx.lineTo(r*0.6, r*0.6);
                    ctx.fill();
                    break;
                
                case 'mario':
                    // Mario - red cap, mustache
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Red cap
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, -r*0.4, r*0.8, Math.PI, 0, true);
                    ctx.fill();
                    ctx.fillRect(-r*0.8, -r*0.4, r*1.6, r*0.2);
                    // M logo
                    ctx.fillStyle = '#fff';
                    ctx.font = `bold ${r*0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('M', 0, -r*0.5);
                    // Face
                    ctx.fillStyle = '#ffd7a8';
                    ctx.beginPath();
                    ctx.arc(0, r*0.1, r*0.6, 0, Math.PI * 2);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.2, -r*0.05, r*0.08, 0, Math.PI * 2);
                    ctx.arc(r*0.2, -r*0.05, r*0.08, 0, Math.PI * 2);
                    ctx.fill();
                    // Mustache
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.ellipse(-r*0.3, r*0.2, r*0.25, r*0.15, 0, 0, Math.PI, true);
                    ctx.ellipse(r*0.3, r*0.2, r*0.25, r*0.15, 0, 0, Math.PI, true);
                    ctx.fill();
                    // Nose
                    ctx.fillStyle = '#ffd7a8';
                    ctx.beginPath();
                    ctx.arc(0, r*0.15, r*0.12, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                default:
                    // Default human climber
                    // Body (circle)
                    ctx.fillStyle = colors.primary;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    // Head details
                    ctx.fillStyle = colors.secondary;
                    ctx.beginPath();
                    ctx.arc(0, -r*0.3, r*0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Backpack
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(-r*0.5, -r*0.1, r, r*0.7);
                    // Helmet
                    ctx.strokeStyle = colors.accent;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, -r*0.3, r*0.6, Math.PI, Math.PI * 2);
                    ctx.stroke();
                    // Goggles
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(-r*0.5, -r*0.4, r*0.4, r*0.2);
                    ctx.fillRect(r*0.1, -r*0.4, r*0.4, r*0.2);
                    // Eyes through goggles
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(-r*0.3, -r*0.3, r*0.08, 0, Math.PI * 2);
                    ctx.arc(r*0.3, -r*0.3, r*0.08, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
            
            // Animated arms/legs for all characters
            ctx.strokeStyle = colors.primary;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            const armSwing = Math.sin(player.armAnimation) * 0.3;
            ctx.beginPath();
            ctx.moveTo(-r*0.7, 0);
            ctx.lineTo(-r*0.9, r*0.5 + armSwing * r);
            ctx.moveTo(r*0.7, 0);
            ctx.lineTo(r*0.9, r*0.5 - armSwing * r);
            ctx.stroke();
        }
        
        // Color interpolation helper
        function interpolateColor(color1, color2, t) {
            const c1 = parseInt(color1.slice(1), 16);
            const c2 = parseInt(color2.slice(1), 16);
            const r1 = (c1 >> 16) & 0xff, g1 = (c1 >> 8) & 0xff, b1 = c1 & 0xff;
            const r2 = (c2 >> 16) & 0xff, g2 = (c2 >> 8) & 0xff, b2 = c2 & 0xff;
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }
        
        // Draw landmarks based on altitude
        function drawLandmarks(ctx, altitude) {
            // Birds (0-500m)
            if (altitude < 600) {
                for (let i = 0; i < 5; i++) {
                    const birdSeed = i * 567.89;
                    const birdAltitude = (birdSeed % 500) + 50;
                    const birdY = game.groundLevel - birdAltitude;
                    
                    // Only draw if on screen
                    const screenY = birdY + game.camera.y;
                    if (screenY > -50 && screenY < displayHeight + 50) {
                        const birdX = ((birdSeed * 1.5) % 800) * (displayWidth / 800) + Math.sin(game.time * 2 + i) * 30;
                        const flap = Math.sin(game.time * 8 + i * 1.5) * 0.3;
                        
                        ctx.save();
                        ctx.translate(birdX, birdY);
                        ctx.strokeStyle = 'rgba(60, 40, 20, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        
                        // Bird V shape
                        ctx.beginPath();
                        ctx.moveTo(-8, 0);
                        ctx.quadraticCurveTo(-4, -5 + flap * 5, 0, 0);
                        ctx.quadraticCurveTo(4, -5 + flap * 5, 8, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
            
            // Planes (500-1000m)
            if (altitude > 400 && altitude < 1200) {
                for (let i = 0; i < 3; i++) {
                    const planeSeed = i * 789.12;
                    const planeAltitude = ((planeSeed % 500) + 500);
                    const planeY = game.groundLevel - planeAltitude;
                    
                    const screenY = planeY + game.camera.y;
                    if (screenY > -100 && screenY < displayHeight + 100) {
                        const planeX = ((game.time * 50 + planeSeed * 100) % (displayWidth + 400)) - 200;
                        
                        ctx.save();
                        ctx.translate(planeX, planeY);
                        
                        // Plane body
                        ctx.fillStyle = 'rgba(200, 200, 220, 0.7)';
                        ctx.fillRect(-30, -4, 60, 8);
                        
                        // Wings
                        ctx.fillRect(-25, -2, 50, 2);
                        ctx.fillRect(-15, -12, 8, 12);
                        
                        // Tail
                        ctx.fillRect(20, -8, 10, 8);
                        
                        // Windows
                        ctx.fillStyle = 'rgba(100, 150, 200, 0.5)';
                        for (let w = -20; w < 20; w += 8) {
                            ctx.fillRect(w, -2, 4, 4);
                        }
                        
                        // Contrail
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(-30, 0);
                        ctx.lineTo(-80, 0);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                }
            }
            
            // Space objects (1000m+)
            if (altitude > 900) {
                // Rockets
                for (let i = 0; i < 2; i++) {
                    const rocketSeed = i * 456.78;
                    const rocketAltitude = ((rocketSeed % 500) + 1000);
                    const rocketY = game.groundLevel - rocketAltitude;
                    
                    const screenY = rocketY + game.camera.y;
                    if (screenY > -150 && screenY < displayHeight + 150) {
                        const rocketX = ((rocketSeed * 1.7) % 700) * (displayWidth / 700);
                        const rocketFloat = Math.sin(game.time * 0.5 + i) * 20;
                        
                        ctx.save();
                        ctx.translate(rocketX, rocketY + rocketFloat);
                        
                        // Rocket body
                        ctx.fillStyle = 'rgba(220, 220, 230, 0.8)';
                        ctx.fillRect(-8, -40, 16, 60);
                        
                        // Nose cone
                        ctx.beginPath();
                        ctx.moveTo(-8, -40);
                        ctx.lineTo(0, -60);
                        ctx.lineTo(8, -40);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Fins
                        ctx.fillStyle = 'rgba(200, 50, 50, 0.7)';
                        ctx.beginPath();
                        ctx.moveTo(-8, 10);
                        ctx.lineTo(-20, 20);
                        ctx.lineTo(-8, 20);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(8, 10);
                        ctx.lineTo(20, 20);
                        ctx.lineTo(8, 20);
                        ctx.fill();
                        
                        // Engine fire
                        ctx.fillStyle = 'rgba(255, 150, 0, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(-6, 20);
                        ctx.lineTo(0, 35 + Math.random() * 10);
                        ctx.lineTo(6, 20);
                        ctx.fill();
                        
                        // Window
                        ctx.fillStyle = 'rgba(100, 150, 255, 0.6)';
                        ctx.beginPath();
                        ctx.arc(0, -10, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
                
                // Moon
                if (altitude > 1200) {
                    const moonY = game.groundLevel - 1500;
                    const screenY = moonY + game.camera.y;
                    if (screenY > -300 && screenY < displayHeight + 300) {
                        const moonX = displayWidth * 0.8;
                        
                        ctx.save();
                        ctx.translate(moonX, moonY);
                        
                        // Moon body
                        ctx.fillStyle = 'rgba(230, 230, 235, 0.9)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 60, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Craters
                        ctx.fillStyle = 'rgba(180, 180, 185, 0.5)';
                        ctx.beginPath();
                        ctx.arc(-15, -10, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(20, 5, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(-10, 20, 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(15, -25, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
                
                // Planets
                if (altitude > 1800) {
                    // Mars-like planet
                    const marsY = game.groundLevel - 2200;
                    const marsScreenY = marsY + game.camera.y;
                    if (marsScreenY > -200 && marsScreenY < displayHeight + 200) {
                        const marsX = displayWidth * 0.2;
                        
                        ctx.save();
                        ctx.translate(marsX, marsY);
                        
                        // Planet body
                        ctx.fillStyle = 'rgba(200, 100, 80, 0.7)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 45, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Surface features
                        ctx.fillStyle = 'rgba(180, 80, 60, 0.4)';
                        ctx.beginPath();
                        ctx.arc(-10, -15, 15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(15, 10, 12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    // Gas giant
                    const jupiterY = game.groundLevel - 2800;
                    if (jupiterY > -300 && jupiterY < displayHeight + 300) {
                        const jupiterX = displayWidth * 0.7;
                        
                        ctx.save();
                        ctx.translate(jupiterX, jupiterY);
                        
                        // Planet body
                        ctx.fillStyle = 'rgba(210, 170, 140, 0.8)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 80, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bands
                        ctx.strokeStyle = 'rgba(180, 140, 110, 0.5)';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.arc(0, 0, 80, 0.3, Math.PI - 0.3);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 0, 80, Math.PI + 0.5, Math.PI * 2 - 0.5);
                        ctx.stroke();
                        
                        // Great Red Spot
                        ctx.fillStyle = 'rgba(200, 100, 80, 0.6)';
                        ctx.beginPath();
                        ctx.ellipse(25, 10, 18, 12, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }
            }
        }

        // Render
        function render() {
            // Calculate altitude-based sky color (static background, no scrolling)
            const altitude = game.maxHeight;
            let skyColor1, skyColor2;
            
            if (altitude < 500) {
                // Low altitude: Bright blue sky
                const t = altitude / 500;
                skyColor1 = interpolateColor('#87ceeb', '#4a90e2', t);
                skyColor2 = interpolateColor('#b0e0ff', '#87ceeb', t);
            } else if (altitude < 1000) {
                // Medium altitude: Darker blue, approaching atmosphere edge
                const t = (altitude - 500) / 500;
                skyColor1 = interpolateColor('#4a90e2', '#2c5f8d', t);
                skyColor2 = interpolateColor('#87ceeb', '#4a90e2', t);
            } else if (altitude < 2000) {
                // High altitude: Deep blue to black, entering space
                const t = (altitude - 1000) / 1000;
                skyColor1 = interpolateColor('#2c5f8d', '#0a1929', t);
                skyColor2 = interpolateColor('#4a90e2', '#1a2f4a', t);
            } else {
                // Space: Black with stars
                skyColor1 = '#000814';
                skyColor2 = '#0a1929';
            }
            
            const skyGradient = ctx.createLinearGradient(0, 0, 0, displayHeight);
            skyGradient.addColorStop(0, skyColor1);
            skyGradient.addColorStop(1, skyColor2);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, displayWidth, displayHeight);
            
            // Draw stars in space (altitude > 1000m)
            if (altitude > 800) {
                const starOpacity = Math.min((altitude - 800) / 400, 1);
                ctx.fillStyle = `rgba(255, 255, 255, ${starOpacity * 0.8})`;
                // Static star positions based on seed
                for (let i = 0; i < 100; i++) {
                    const seed = i * 1234.567;
                    const x = (seed % 1000 / 1000) * displayWidth;
                    const y = ((seed * 1.234) % 1000 / 1000) * displayHeight;
                    const size = ((seed * 2.345) % 100 / 100) * 2;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.save();
            ctx.translate(0, -game.camera.y);
            
            // Draw landmarks based on altitude zones (in world space)
            drawLandmarks(ctx, game.maxHeight);
            
            // Draw cliff face with realistic vertical columns
            const baseCliffWidth = displayWidth * 0.6;
            const cliffCenterX = displayWidth / 2;
            const cliffStartY = Math.floor((game.camera.y - displayHeight) / 100) * 100;
            const cliffEndY = game.camera.y + displayHeight * 3;
            
            // Build cliff outline
            ctx.beginPath();
            let firstPoint = true;
            
            // Left edge
            for (let y = cliffStartY; y <= cliffEndY; y += 50) {
                const bounds = getCliffBounds(y);
                if (firstPoint) {
                    ctx.moveTo(bounds.left, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(bounds.left, y);
                }
            }
            
            // Right edge (going back up)
            for (let y = cliffEndY; y >= cliffStartY; y -= 50) {
                const bounds = getCliffBounds(y);
                ctx.lineTo(bounds.right, y);
            }
            
            ctx.closePath();
            
            // Fill base cliff color
            ctx.fillStyle = '#7a6954';
            ctx.fill();
            
            // Draw vertical striations to make it look like a real cliff
            const numColumns = 30;
            for (let i = 0; i < numColumns; i++) {
                const yStart = cliffStartY;
                const yEnd = cliffEndY;
                
                // Each column has slight variations
                const columnOffset = (i / numColumns) * baseCliffWidth;
                
                ctx.strokeStyle = i % 2 === 0 ? 'rgba(100, 85, 70, 0.4)' : 'rgba(110, 95, 80, 0.3)';
                ctx.lineWidth = 3 + Math.random() * 4;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                for (let y = yStart; y <= yEnd; y += 40) {
                    const bounds = getCliffBounds(y);
                    const cliffWidth = bounds.right - bounds.left;
                    
                    // Position column within cliff bounds
                    const x = bounds.left + (columnOffset / baseCliffWidth) * cliffWidth;
                    
                    // Add micro-variations for natural look
                    const wobble = Math.sin(y * 0.03 + i) * 2;
                    
                    if (y === yStart) {
                        ctx.moveTo(x + wobble, y);
                    } else {
                        ctx.lineTo(x + wobble, y);
                    }
                }
                ctx.stroke();
            }
            
            // Add darker vertical cracks between columns
            for (let i = 0; i < 8; i++) {
                const yStart = cliffStartY;
                const yEnd = cliffEndY;
                const crackOffset = ((i + 0.5) / 8) * baseCliffWidth;
                
                ctx.strokeStyle = 'rgba(40, 30, 25, 0.5)';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                for (let y = yStart; y <= yEnd; y += 60) {
                    const bounds = getCliffBounds(y);
                    const cliffWidth = bounds.right - bounds.left;
                    const x = bounds.left + (crackOffset / baseCliffWidth) * cliffWidth;
                    const wobble = Math.sin(y * 0.02 + i * 2) * 3;
                    
                    if (y === yStart) {
                        ctx.moveTo(x + wobble, y);
                    } else {
                        ctx.lineTo(x + wobble, y);
                    }
                }
                ctx.stroke();
            }
            
            // Draw ground at bottom - extends in all directions
            if (game.groundLevel - game.camera.y < displayHeight + 100) {
                const groundBounds = getCliffBounds(game.groundLevel);
                
                // Draw main ground platform extending outward
                const groundGradient = ctx.createLinearGradient(0, game.groundLevel, 0, game.groundLevel + 300);
                groundGradient.addColorStop(0, '#8b7355');
                groundGradient.addColorStop(0.3, '#6b5943');
                groundGradient.addColorStop(1, '#4a3f2f');
                ctx.fillStyle = groundGradient;
                
                // Ground extends from cliff edges outward and downward
                ctx.fillRect(0, game.groundLevel, displayWidth, 500);
                
                // Draw cliff base where it meets ground
                ctx.fillStyle = '#7a6954';
                ctx.fillRect(groundBounds.left, game.groundLevel - 20, groundBounds.right - groundBounds.left, 20);
                
                // Animated grass on cliff top at ground level
                ctx.fillStyle = '#6b8e23';
                for (let i = 0; i < 30; i++) {
                    const x = groundBounds.left + (i * ((groundBounds.right - groundBounds.left) / 30));
                    const sway = Math.sin(game.time * 2 + i * 0.5) * 2;
                    ctx.save();
                    ctx.translate(x, game.groundLevel);
                    ctx.rotate(sway * 0.1);
                    ctx.fillRect(-1.5, -2, 3, 8);
                    ctx.restore();
                }
            }
            
            // Draw summit platform for multiplayer at 1000m
            if (game.mode === 'multiplayer') {
                const summitY = game.groundLevel - (1000 * 10);
                if (summitY > game.camera.y - 200 && summitY < game.camera.y + displayHeight + 200) {
                    const summitBounds = getCliffBounds(summitY);
                    const summitWidth = summitBounds.right - summitBounds.left;
                    
                    // Summit platform (flat top)
                    ctx.fillStyle = '#9d8f7f';
                    ctx.fillRect(summitBounds.left, summitY - 30, summitWidth, 30);
                    
                    // Summit edge highlight
                    ctx.fillStyle = '#b8a89f';
                    ctx.fillRect(summitBounds.left, summitY - 30, summitWidth, 5);
                    
                    // Snow cap on summit
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = 0.7;
                    ctx.fillRect(summitBounds.left, summitY - 30, summitWidth, 10);
                    ctx.globalAlpha = 1;
                    
                    // Victory flag at summit
                    const flagX = summitBounds.center;
                    const flagY = summitY - 30;
                    
                    // Flag pole
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(flagX, flagY);
                    ctx.lineTo(flagX, flagY - 60);
                    ctx.stroke();
                    
                    // Waving flag
                    const wave = Math.sin(game.time * 3) * 5;
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(flagX, flagY - 60);
                    ctx.lineTo(flagX + 40 + wave, flagY - 50);
                    ctx.lineTo(flagX + wave, flagY - 40);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Victory text on flag
                    ctx.fillStyle = '#654321';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üèÜ', flagX + 20 + wave/2, flagY - 47);
                    
                    // "FINISH" text below summit
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 10;
                    ctx.fillText('üèÅ FINISH LINE üèÅ', summitBounds.center, summitY - 60);
                    ctx.shadowBlur = 0;
                }
            }
            
            // Draw milestone markers as white translucent dashed lines
            for (let milestone of game.milestones) {
                const milestoneY = game.groundLevel - (milestone * 10);
                
                if (milestoneY > game.camera.y - 50 && milestoneY < game.camera.y + displayHeight + 50) {
                    const bounds = getCliffBounds(milestoneY);
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([15, 15]);
                    ctx.beginPath();
                    ctx.moveTo(bounds.left, milestoneY);
                    ctx.lineTo(bounds.right, milestoneY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Draw milestone flags with animation
            for (let flag of game.milestoneFlags) {
                if (flag.y > game.camera.y - 50 && flag.y < game.camera.y + displayHeight + 50) {
                    const bounds = getCliffBounds(flag.y);
                    const edgeX = flag.leftSide ? bounds.left + 20 : bounds.right - 20;
                    
                    // Flag pole
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(edgeX, flag.y);
                    ctx.lineTo(edgeX, flag.y - 40);
                    ctx.stroke();
                    
                    // Animated flag (waving)
                    const wave = Math.sin(game.time * 3 + flag.y * 0.01) * 3;
                    ctx.fillStyle = '#d4a78a';
                    ctx.beginPath();
                    ctx.moveTo(edgeX, flag.y - 40);
                    ctx.lineTo(edgeX + (flag.leftSide ? 35 + wave : -35 + wave), flag.y - 30);
                    ctx.lineTo(edgeX, flag.y - 20);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#654321';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = flag.leftSide ? 'left' : 'right';
                    ctx.fillText(flag.height + 'm', edgeX + (flag.leftSide ? 5 : -5), flag.y - 27);
                }
            }
            
            // Draw decorations with animations
            for (let dec of game.decorations) {
                if (dec.y < game.camera.y - 50 || dec.y > game.camera.y + displayHeight + 50) continue;
                
                const bounds = getCliffBounds(dec.y);
                
                // Check if decoration is within cliff bounds
                if (dec.x < bounds.left || dec.x > bounds.right) continue;
                
                if (dec.type === 'shrub') {
                    const sway = Math.sin(game.time * 2 + dec.x * 0.01) * 2;
                    ctx.save();
                    ctx.translate(dec.x, dec.y);
                    ctx.scale(1 + sway * 0.05, 1 - sway * 0.05);
                    
                    ctx.fillStyle = '#4a7c2e';
                    ctx.beginPath();
                    ctx.arc(0, 0, dec.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#3a5f1e';
                    ctx.beginPath();
                    ctx.arc(-dec.size / 4, -dec.size / 6, dec.size / 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                } else if (dec.type === 'tree') {
                    const sway = Math.sin(game.time * 1.5 + dec.x * 0.01) * 3;
                    ctx.save();
                    ctx.translate(dec.x, dec.y);
                    ctx.rotate(sway * 0.02);
                    
                    ctx.fillStyle = '#5d4037';
                    ctx.fillRect(-4, -dec.size / 3, 8, dec.size / 2);
                    
                    ctx.fillStyle = '#4a7c2e';
                    ctx.beginPath();
                    ctx.moveTo(0, -dec.size);
                    ctx.lineTo(-dec.size / 2, -dec.size / 3);
                    ctx.lineTo(dec.size / 2, -dec.size / 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                } else if (dec.type === 'goat') {
                    // Detailed animated goat
                    ctx.save();
                    ctx.translate(dec.x, dec.y);
                    if (!dec.facingRight) ctx.scale(-1, 1);
                    
                    const bob = Math.sin(game.time * 2 + dec.x * 0.1) * 2;
                    ctx.translate(0, bob);
                    
                    // Body
                    ctx.fillStyle = '#f5f5f5';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, dec.size / 2, dec.size / 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Legs
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    const legBob = Math.sin(game.time * 3 + dec.x * 0.1) * 1;
                    ctx.beginPath();
                    ctx.moveTo(-dec.size / 4, dec.size / 3);
                    ctx.lineTo(-dec.size / 4, dec.size / 3 + 8 + legBob);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(dec.size / 6, dec.size / 3);
                    ctx.lineTo(dec.size / 6, dec.size / 3 + 8 - legBob);
                    ctx.stroke();
                    
                    // Head
                    ctx.fillStyle = '#f5f5f5';
                    ctx.beginPath();
                    ctx.arc(dec.size / 3, -dec.size / 4, dec.size / 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Snout
                    ctx.fillStyle = '#d4d4d4';
                    ctx.beginPath();
                    ctx.ellipse(dec.size / 2, -dec.size / 5, dec.size / 8, dec.size / 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(dec.size / 3 + 3, -dec.size / 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Horns
                    ctx.strokeStyle = '#3d2817';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(dec.size / 3 - 3, -dec.size / 2);
                    ctx.quadraticCurveTo(dec.size / 3 - 5, -dec.size / 2 - 8, dec.size / 3, -dec.size / 2 - 10);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(dec.size / 3 + 3, -dec.size / 2);
                    ctx.quadraticCurveTo(dec.size / 3 + 5, -dec.size / 2 - 8, dec.size / 3, -dec.size / 2 - 10);
                    ctx.stroke();
                    
                    // Tail
                    const tailWag = Math.sin(game.time * 4 + dec.x * 0.1) * 5;
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-dec.size / 2, 0);
                    ctx.lineTo(-dec.size / 2 - 5 + tailWag, -5);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Draw holds with subtle animation
            for (let hold of game.holds) {
                if (hold.broken) continue;
                
                const baseColor = hold.breakable ? '#8b5a3c' : 
                                 hold.moving ? '#a0826d' :
                                 '#7a6450';
                
                const pulse = hold.moving ? 1 + Math.sin(game.time * 3) * 0.05 : 1;
                
                ctx.fillStyle = baseColor;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 4;
                
                ctx.beginPath();
                ctx.ellipse(hold.x, hold.y, (hold.width / 2) * pulse, (hold.height / 2) * pulse, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.beginPath();
                ctx.ellipse(hold.x - hold.width / 5, hold.y - hold.height / 5, hold.width / 4, hold.height / 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(hold.x, hold.y + hold.height / 3, hold.width / 2.5, hold.height / 6, 0, 0, Math.PI);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw trajectory if aiming
            if (game.player.aimMode && game.player.grounded && game.player.powerPercent > 0) {
                const dx = game.player.aimCurrentX - game.player.x;
                const dy = game.player.aimCurrentY - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    const angle = Math.atan2(dy, dx);
                    const basePower = (250 + (game.player.powerPercent / 100) * 650) * 1.4;
                    const finalPower = basePower * game.player.jumpBoost;
                    const hasBooost = game.player.jumpBoost > 1.05;
                    
                    // Draw trajectory with boost coloring
                    ctx.strokeStyle = hasBooost ? 'rgba(255, 215, 0, 0.9)' : 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = hasBooost ? 5 : 3;
                    ctx.setLineDash([12, 12]);
                    
                    if (hasBooost) {
                        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
                        ctx.shadowBlur = 10;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(game.player.x, game.player.y);
                    
                    let px = game.player.x;
                    let py = game.player.y;
                    let pvx = Math.cos(angle) * finalPower;
                    let pvy = Math.sin(angle) * finalPower;
                    
                    for (let i = 0; i < 8; i++) {
                        pvy += 1500 * 0.05;
                        px += pvx * 0.05;
                        py += pvy * 0.05;
                        ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    
                    // Draw sparkles along boosted trajectory
                    if (hasBooost) {
                        ctx.fillStyle = '#ffd700';
                        px = game.player.x;
                        py = game.player.y;
                        pvx = Math.cos(angle) * finalPower;
                        pvy = Math.sin(angle) * finalPower;
                        
                        for (let i = 0; i < 5; i++) {
                            pvy += 1500 * 0.05;
                            px += pvx * 0.05;
                            py += pvy * 0.05;
                            
                            const sparkleSize = 2 + Math.sin(game.time * 8 + i) * 1;
                            ctx.beginPath();
                            ctx.arc(px, py, sparkleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // Draw aim point
                    ctx.fillStyle = hasBooost ? 'rgba(255, 215, 0, 0.9)' : 'rgba(139, 115, 85, 0.8)';
                    ctx.beginPath();
                    ctx.arc(game.player.aimCurrentX, game.player.aimCurrentY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Show boost multiplier text near aim point
                    if (hasBooost) {
                        ctx.fillStyle = '#ffd700';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`x${game.player.jumpBoost.toFixed(1)}`, game.player.aimCurrentX, game.player.aimCurrentY - 20);
                    }
                }
            }
            
            // Draw NPCs in multiplayer mode
            if (game.mode === 'multiplayer') {
                for (let npc of game.npcs) {
                    ctx.save();
                    ctx.translate(npc.x, npc.y);
                    ctx.rotate(npc.rotation);
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(0, npc.radius + 3, npc.radius * 0.8, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body
                    ctx.fillStyle = npc.color;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, npc.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Simple limbs
                    ctx.strokeStyle = npc.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    // Arms
                    ctx.beginPath();
                    ctx.moveTo(-5, -2);
                    ctx.lineTo(-10, -12);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(5, -2);
                    ctx.lineTo(10, -12);
                    ctx.stroke();
                    
                    // Legs
                    ctx.beginPath();
                    ctx.moveTo(-3, 7);
                    ctx.lineTo(-6, 14);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(3, 7);
                    ctx.lineTo(6, 14);
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // Name label above NPC
                    ctx.fillStyle = npc.color;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(npc.name, npc.x, npc.y - 25);
                    ctx.fillText(npc.name, npc.x, npc.y - 25);
                }
            }
            
            // Draw player with animation
            const skin = skins[game.player.skin] || skins.default;
            
            ctx.save();
            ctx.translate(game.player.x, game.player.y);
            
            // Celebration animation
            if (game.player.celebrating) {
                const jumpHeight = Math.abs(Math.sin(game.player.celebrationTime * 3)) * 20;
                ctx.translate(0, -jumpHeight);
                ctx.rotate(0); // Keep upright during celebration
                
                // Confetti particles
                if (Math.random() < 0.3) {
                    const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
                    game.particles.push({
                        x: game.player.x + (Math.random() - 0.5) * 40,
                        y: game.player.y - 30,
                        vx: (Math.random() - 0.5) * 200,
                        vy: -Math.random() * 300,
                        life: 1.0,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    });
                }
            } else {
                ctx.rotate(game.player.rotation);
            }
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(0, game.player.radius + 3, game.player.radius * 0.8, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw character based on skin type
            drawCharacter(ctx, skin, game.player);
            
            ctx.restore();
            if (game.player.celebrating) {
                // Victory pose - arms raised
                const wave = Math.sin(game.player.armAnimation) * 10;
                
                ctx.beginPath();
                ctx.moveTo(-6, -3);
                ctx.lineTo(-12 - wave, -25);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(6, -3);
                ctx.lineTo(12 + wave, -25);
                ctx.stroke();
                
                // Legs - standing
                ctx.beginPath();
                ctx.moveTo(-4, 8);
                ctx.lineTo(-8, 18);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(4, 8);
                ctx.lineTo(8, 18);
                ctx.stroke();
            } else {
                const armSwing = game.player.grounded ? Math.sin(game.player.armAnimation) * 3 : 0;
                const legSwing = game.player.grounded ? Math.sin(game.player.legAnimation) * 2 : 0;
                
                // Arms
                ctx.beginPath();
                ctx.moveTo(-6, -3);
                ctx.lineTo(-12 + armSwing, -14);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(6, -3);
                ctx.lineTo(12 - armSwing, -14);
                ctx.stroke();
                
                // Legs
                ctx.beginPath();
                ctx.moveTo(-4, 8);
                ctx.lineTo(-8 + legSwing, 16);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(4, 8);
                ctx.lineTo(8 - legSwing, 16);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Draw particles
            for (let p of game.particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life * 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            ctx.restore();
            
            // Draw countdown for multiplayer
            if (game.mode === 'multiplayer' && game.countdown > 0) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, displayWidth, displayHeight);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 120px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 20;
                ctx.fillText(game.countdown, displayWidth / 2, displayHeight / 2);
                
                ctx.font = 'bold 32px Arial';
                ctx.fillText('GET READY!', displayWidth / 2, displayHeight / 2 + 100);
                
                // Game tip about breakable holds
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText('üî¥ Red rocks break when', displayWidth / 2, displayHeight / 2 + 170);
                ctx.fillText('jump power is over 80%!', displayWidth / 2, displayHeight / 2 + 205);
                
                ctx.restore();
            }
            
            // Draw "GO!" when race starts
            if (game.mode === 'multiplayer' && game.raceStarted && game.time < 1) {
                ctx.save();
                ctx.fillStyle = '#4ecdc4';
                ctx.font = 'bold 100px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 20;
                ctx.fillText('GO!', displayWidth / 2, displayHeight / 2);
                ctx.restore();
            }
        }
        let touching = false;
        let touchId = null;
        let powerBarDragging = false;

        function updatePowerBar(clientX) {
            const powerBarContainer = document.getElementById('powerBarContainer');
            const rect = powerBarContainer.getBoundingClientRect();
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            const percent = Math.round((x / rect.width) * 100);
            
            game.player.powerPercent = percent;
            document.getElementById('powerFill').style.width = percent + '%';
            document.getElementById('powerPercentage').textContent = percent + '%';
        }

        function startAim(x, y) {
            console.log('startAim called:', {
                state: game.state,
                grounded: game.player.grounded,
                snapping: game.player.snapping,
                power: game.player.powerPercent,
                playerY: game.player.y,
                groundLevel: game.groundLevel,
                currentHold: game.player.currentHold ? 'yes' : 'no'
            });
            
            if (game.state !== 'playing') {
                console.log('Blocked: game.state not playing');
                return;
            }
            if (!game.player.grounded) {
                console.log('Blocked: player not grounded');
                return;
            }
            if (game.player.powerPercent === 0) {
                console.log('Blocked: power is 0');
                return;
            }
            
            // Convert screen coords to world coords
            const worldY = y + game.camera.y;
            
            console.log('Aim started at', x, y);
            game.player.aimMode = true;
            game.player.aimStartX = x;
            game.player.aimStartY = worldY;
            game.player.aimCurrentX = x;
            game.player.aimCurrentY = worldY;
        }

        function updateAim(x, y) {
            if (!game.player.aimMode) return;
            
            const worldY = y + game.camera.y;
            game.player.aimCurrentX = x;
            game.player.aimCurrentY = worldY;
        }

        // Analyze which holds are reachable with maximum normal jump power
        function analyzeReachableHolds() {
            const maxNormalPower = (250 + 650) * 1.4; // Max power at 100%
            game.player.reachableHolds = [];
            
            // Test 8 directions around the player
            const testAngles = [
                -Math.PI/2, // Up
                -Math.PI/3, // Up-right
                -2*Math.PI/3, // Up-left
                -Math.PI/4, // Diagonal up-right
                -3*Math.PI/4, // Diagonal up-left
                0, // Right (if hold is to the side)
                Math.PI, // Left
                -Math.PI/6 // Shallow up
            ];
            
            for (const angle of testAngles) {
                const reachable = simulateJumpPath(
                    game.player.x,
                    game.player.y,
                    angle,
                    maxNormalPower
                );
                
                for (const hold of reachable) {
                    if (!game.player.reachableHolds.includes(hold)) {
                        game.player.reachableHolds.push(hold);
                    }
                }
            }
            
            // Calculate required boost
            if (game.player.reachableHolds.length === 0) {
                // No holds reachable - calculate boost needed
                game.player.jumpBoost = calculateBoostMultiplier();
            } else {
                // Reset boost
                game.player.jumpBoost = 1.0;
            }
        }

        // Simulate a jump path and return which holds would be contacted
        function simulateJumpPath(startX, startY, angle, power) {
            const contactedHolds = [];
            const dt = 0.033; // ~30 fps simulation
            const maxSteps = 150; // Simulate ~5 seconds
            
            let x = startX;
            let y = startY;
            let vx = Math.cos(angle) * power;
            let vy = Math.sin(angle) * power;
            
            for (let step = 0; step < maxSteps; step++) {
                // Apply gravity
                vy += 1500 * dt;
                
                // Update position
                x += vx * dt;
                y += vy * dt;
                
                // Stop if fallen below starting position
                if (y > startY + 100) break;
                
                // Check collision with holds
                for (const hold of game.holds) {
                    if (hold.broken) continue;
                    if (contactedHolds.includes(hold)) continue;
                    
                    const dx = x - hold.x;
                    const dy = y - hold.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const collisionRadius = game.player.radius + Math.max(hold.width / 2, hold.height / 2);
                    
                    if (distance < collisionRadius) {
                        contactedHolds.push(hold);
                    }
                }
            }
            
            return contactedHolds;
        }

        // Calculate the boost multiplier needed to reach the next two highest holds
        function calculateBoostMultiplier() {
            // Find all holds above the player
            const holdsAbove = game.holds
                .filter(hold => !hold.broken && hold.y < game.player.y)
                .sort((a, b) => a.y - b.y); // Sort by Y (lowest Y = highest position)
            
            if (holdsAbove.length === 0) return 1.0;
            
            // Target the second highest hold, or first if there's only one
            const targetIndex = Math.min(1, holdsAbove.length - 1);
            const targetHold = holdsAbove[targetIndex];
            
            // Calculate distance to target
            const dx = targetHold.x - game.player.x;
            const dy = targetHold.y - game.player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Estimate required power multiplier
            // Base formula: power needed ‚âà sqrt(distance) * gravity compensation
            const basePower = (250 + 650) * 1.4;
            const requiredPower = Math.sqrt(Math.abs(dy) * 1500) * 1.5;
            const multiplier = requiredPower / basePower;
            
            // Clamp between 1.0 and 2.5 (don't make it too easy or too hard)
            return Math.max(1.0, Math.min(2.5, multiplier));
        }

        function releaseJump() {
            if (game.state !== 'playing') return;
            if (!game.player.aimMode) return;
            if (!game.player.grounded) return;
            
            game.player.aimMode = false;
            
            const dx = game.player.aimCurrentX - game.player.x;
            const dy = game.player.aimCurrentY - game.player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Need minimum drag distance
            if (distance < 20) {
                return;
            }
            
            const angle = Math.atan2(dy, dx);
            
            // Apply dynamic boost if no holds are reachable
            const basePower = (250 + (game.player.powerPercent / 100) * 650) * 1.4;
            const finalPower = basePower * game.player.jumpBoost;
            
            // Store the jump power percent for breakable hold checking
            game.player.lastJumpPowerPercent = game.player.powerPercent;
            
            // Show boost indicator if boost is active
            if (game.player.jumpBoost > 1.05) {
                showBoostIndicator(game.player.jumpBoost);
                vibrate(50);
            }
            
            // Mark the hold we're leaving with current timestamp
            if (game.player.currentHold) {
                game.player.currentHold.lastLeftTime = Date.now();
            }
            
            game.player.vx = Math.cos(angle) * finalPower;
            game.player.vy = Math.sin(angle) * finalPower;
            game.player.grounded = false;
            game.player.snapping = false;
            game.player.currentHold = null;
            
            createJumpParticles(game.player.x, game.player.y, game.player.jumpBoost > 1.05);
            vibrate(20);
        }

        function showTimeBonus(seconds = 20) {
            const indicator = document.createElement('div');
            indicator.style.position = 'absolute';
            indicator.style.top = '50%';
            indicator.style.left = '50%';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.fontSize = '32px';
            indicator.style.fontWeight = 'bold';
            indicator.style.color = '#4ecdc4';
            indicator.style.textShadow = '0 0 20px rgba(78, 205, 196, 0.8), 0 4px 8px rgba(0, 0, 0, 0.8)';
            indicator.style.zIndex = '100';
            indicator.style.pointerEvents = 'none';
            indicator.textContent = `‚è±Ô∏è +${seconds} SECONDS!`;
            indicator.style.animation = 'fadeOut 1.5s ease-out';
            
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.remove();
            }, 1500);
        }

        function showBoostIndicator(multiplier) {
            const indicator = document.createElement('div');
            indicator.style.position = 'absolute';
            indicator.style.top = '50%';
            indicator.style.left = '50%';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.fontSize = '28px';
            indicator.style.fontWeight = 'bold';
            indicator.style.color = '#ffd700';
            indicator.style.textShadow = '0 0 20px rgba(255, 215, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.8)';
            indicator.style.zIndex = '100';
            indicator.style.pointerEvents = 'none';
            indicator.textContent = `‚ö° POWER BOOST x${multiplier.toFixed(1)}!`;
            indicator.style.animation = 'fadeOut 1.2s ease-out';
            
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.remove();
            }, 1200);
        }

        // Power bar interaction
        const powerBarContainer = document.getElementById('powerBarContainer');
        
        powerBarContainer.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            powerBarDragging = true;
            updatePowerBar(e.clientX);
        });

        powerBarContainer.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            powerBarDragging = true;
            const touch = e.touches[0];
            updatePowerBar(touch.clientX);
        });

        document.addEventListener('mousemove', (e) => {
            if (powerBarDragging) {
                updatePowerBar(e.clientX);
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (powerBarDragging) {
                const touch = e.touches[0];
                updatePowerBar(touch.clientX);
            }
        });

        document.addEventListener('mouseup', () => {
            powerBarDragging = false;
        });

        document.addEventListener('touchend', () => {
            powerBarDragging = false;
        });

        // Canvas touch handling for aiming
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (touchId !== null) return;
            if (powerBarDragging) return;
            
            const touch = e.touches[0];
            touchId = touch.identifier;
            touching = true;
            startAim(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touching) return;
            
            for (let touch of e.touches) {
                if (touch.identifier === touchId) {
                    updateAim(touch.clientX, touch.clientY);
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            for (let touch of e.changedTouches) {
                if (touch.identifier === touchId) {
                    touching = false;
                    touchId = null;
                    releaseJump();
                    break;
                }
            }
        }, { passive: false });

        // Mouse handling for canvas
        canvas.addEventListener('mousedown', (e) => {
            if (powerBarDragging) return;
            touching = true;
            startAim(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!touching) return;
            updateAim(e.clientX, e.clientY);
        });

        canvas.addEventListener('mouseup', (e) => {
            touching = false;
            releaseJump();
        });

        // Check if multiplayer race is finished
        function checkRaceFinish() {
            game.raceFinished = true;
            
            // Determine player's position
            const playerPosition = game.finishOrder.indexOf('YOU') + 1;
            
            // Show victory screen with position
            setTimeout(() => {
                winGame(playerPosition);
            }, 1000);
        }

        // NPC System for Multiplayer
        const npcNames = ['Alex', 'Sam', 'Riley', 'Jordan', 'Casey', 'Morgan'];
        const npcColors = ['#4ecdc4', '#ffe66d', '#95e1d3', '#a78bfa', '#ff9a56', '#ff6b9d'];
        
        function initializeNPCs() {
            game.npcs = [];
            const numNPCs = 3;
            
            for (let i = 0; i < numNPCs; i++) {
                game.npcs.push({
                    name: npcNames[i],
                    color: npcColors[i],
                    x: displayWidth / 2,
                    y: game.groundLevel - 60,
                    vx: 0,
                    vy: 0,
                    radius: 15,
                    currentHold: game.holds[0],
                    grounded: true,
                    snapping: false,
                    snapProgress: 0,
                    rotation: 0,
                    height: 0,
                    nextJumpTime: Date.now() + 999999, // Will be set after countdown
                    skill: 0.75 + Math.random() * 0.25,
                    reactionTime: 300 + Math.random() * 200,
                    targetHold: null,
                    finished: false
                });
            }
        }
        
        function updateNPCs(dt) {
            if (game.mode !== 'multiplayer') return;
            if (!game.raceStarted) return; // Don't move during countdown
            
            const currentTime = Date.now();
            
            for (let npc of game.npcs) {
                // Skip if already finished
                if (npc.finished) continue;
                
                // Update height
                npc.height = Math.max(0, Math.floor((game.groundLevel - npc.y) / 10));
                
                // Check if NPC reached 1000m
                if (npc.height >= 1000 && !game.raceFinished) {
                    npc.finished = true;
                    game.finishOrder.push(npc.name);
                    
                    // Check if all racers finished
                    checkRaceFinish();
                }
                
                // Handle snapping
                if (npc.snapping && npc.currentHold) {
                    npc.snapProgress += dt * 8;
                    
                    if (npc.snapProgress >= 1) {
                        npc.snapping = false;
                        npc.grounded = true;
                        npc.vx = 0;
                        npc.vy = 0;
                        npc.x = npc.currentHold.x;
                        npc.y = npc.currentHold.y - npc.currentHold.height / 2 - npc.radius;
                        npc.targetHold = null;
                        
                        // Schedule next jump (3x slower than before)
                        npc.nextJumpTime = currentTime + (npc.reactionTime / npc.skill) * 3;
                    } else {
                        const targetX = npc.currentHold.x;
                        const targetY = npc.currentHold.y - npc.currentHold.height / 2 - npc.radius;
                        npc.x += (targetX - npc.x) * npc.snapProgress;
                        npc.y += (targetY - npc.y) * npc.snapProgress;
                    }
                    continue;
                }
                
                // AI jump logic
                if (npc.grounded && currentTime >= npc.nextJumpTime) {
                    npcJump(npc);
                }
                
                // Physics when airborne
                if (!npc.grounded) {
                    npc.vy += 1500 * dt;
                    npc.x += npc.vx * dt;
                    npc.y += npc.vy * dt;
                    npc.rotation = Math.atan2(npc.vy, npc.vx);
                    
                    // Collision detection
                    for (let hold of game.holds) {
                        if (hold.broken) continue;
                        
                        const dx = npc.x - hold.x;
                        const dy = npc.y - hold.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const collisionDist = npc.radius + Math.max(hold.width / 2, hold.height / 2);
                        
                        if (dist < collisionDist) {
                            // Check if this is a breakable hold and if NPC should break it
                            if (hold.breakable) {
                                const impactSpeed = Math.sqrt(npc.vx * npc.vx + npc.vy * npc.vy);
                                // NPCs can break holds on high-speed impacts
                                if (impactSpeed > 5000) {
                                    hold.broken = true;
                                    createBreakParticles(hold.x, hold.y);
                                    createImpactEffect(hold.x, hold.y, impactSpeed);
                                    npc.vx *= 0.3;
                                    npc.vy *= 0.3;
                                    continue;
                                }
                            }
                            
                            npc.currentHold = hold;
                            npc.snapping = true;
                            npc.snapProgress = 0;
                            break;
                        }
                    }
                }
                
                // Fall detection - respawn at ground
                if (npc.y > game.groundLevel + 50) {
                    npc.y = game.groundLevel - 60;
                    npc.x = displayWidth / 2 + (Math.random() - 0.5) * 100;
                    npc.vx = 0;
                    npc.vy = 0;
                    npc.grounded = true;
                    npc.height = 0;
                    npc.currentHold = game.holds[0];
                    npc.nextJumpTime = currentTime + 6000; // 3x slower (was 2000ms)
                }
            }
        }
        
        function npcJump(npc) {
            // Find reachable holds above using smart pathfinding
            const holdsAbove = game.holds.filter(hold => 
                !hold.broken && 
                hold.y < npc.y - 50 && // Must be significantly above
                Math.abs(hold.x - npc.x) < 300 // Within reasonable horizontal range
            ).sort((a, b) => a.y - b.y); // Sort by height (highest first)
            
            if (holdsAbove.length === 0) return;
            
            // Smart target selection based on skill
            let targetHold;
            
            if (npc.skill > 0.9) {
                // Expert NPCs: Look for optimal paths, skip breakables if possible
                const safeHolds = holdsAbove.filter(h => !h.breakable);
                const lookAhead = Math.min(5, safeHolds.length > 0 ? safeHolds.length : holdsAbove.length);
                targetHold = (safeHolds.length > 0 ? safeHolds : holdsAbove)[Math.floor(Math.random() * lookAhead)];
            } else if (npc.skill > 0.8) {
                // Good NPCs: Look ahead 2-3 holds
                const lookAhead = Math.min(3, holdsAbove.length);
                targetHold = holdsAbove[Math.floor(Math.random() * lookAhead)];
            } else {
                // Average NPCs: Look ahead 1-2 holds
                const lookAhead = Math.min(2, holdsAbove.length);
                targetHold = holdsAbove[Math.floor(Math.random() * lookAhead)];
            }
            
            if (!targetHold) return;
            
            npc.targetHold = targetHold;
            
            // Calculate optimal jump angle and power
            const dx = targetHold.x - npc.x;
            const dy = targetHold.y - npc.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Better NPCs use more optimal power calculations
            const optimalPower = Math.sqrt(Math.abs(dy) * 1500) * 1.5;
            const powerVariation = (1 - npc.skill) * 0.3; // Less variation for better NPCs
            const power = optimalPower * (1 + (Math.random() - 0.5) * powerVariation);
            
            // Calculate angle with slight randomness (less for better NPCs)
            const idealAngle = Math.atan2(dy, dx);
            const angleVariation = (1 - npc.skill) * 0.15; // Up to ¬±8.6 degrees for worst NPCs
            const angle = idealAngle + (Math.random() - 0.5) * angleVariation;
            
            npc.vx = Math.cos(angle) * power;
            npc.vy = Math.sin(angle) * power;
            npc.grounded = false;
            npc.snapping = false;
            npc.currentHold = null;
        }
        
        // Konami Code Easter Egg (‚Üë‚Üë‚Üì‚Üì‚Üê‚Üí‚Üê‚ÜíBA + Enter)
        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a', 'Enter'];
        let konamiIndex = 0;
        let konamiUnlocked = false;
        
        document.addEventListener('keydown', function(e) {
            // Check if the key matches the next key in the sequence
            if (e.key === konamiCode[konamiIndex]) {
                konamiIndex++;
                
                // If we've completed the sequence
                if (konamiIndex === konamiCode.length) {
                    konamiUnlocked = true;
                    konamiIndex = 0;
                    
                    // Show warp button with flash effect
                    const warpToggle = document.getElementById('warpToggle');
                    if (warpToggle && game.state === 'playing') {
                        warpToggle.style.display = 'block';
                        
                        // Flash effect to indicate unlock
                        const flash = document.createElement('div');
                        flash.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(212, 160, 60, 0.4); pointer-events: none; z-index: 100;';
                        document.body.appendChild(flash);
                        setTimeout(() => flash.remove(), 300);
                        
                        // Play success sound (visual feedback)
                        warpToggle.style.animation = 'pulse 0.5s ease-in-out';
                        setTimeout(() => warpToggle.style.animation = '', 500);
                    }
                }
            } else {
                // Reset if wrong key pressed
                konamiIndex = 0;
            }
        });
        
        // CSS animation for warp button unlock
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.2); }
            }
        `;
        document.head.appendChild(style);

        // Game loop with FPS limiting for mobile battery life
        let lastTime = Date.now();
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;
        let lastFrameTime = Date.now();
        
        function gameLoop() {
            const now = Date.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            const timeSinceLastFrame = now - lastFrameTime;
            
            // FPS limiting
            if (timeSinceLastFrame < FRAME_TIME) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            lastTime = now;
            lastFrameTime = now - (timeSinceLastFrame % FRAME_TIME);
            
            if (game.state === 'playing' || game.state === 'victory') {
                game.time += dt;
                updatePlayer(dt);
                updateNPCs(dt);
                updateParticles(dt);
                
                // Update timer in solo mode
                if (game.mode === 'solo' && game.timerActive && game.state === 'playing') {
                    game.timer -= dt;
                    
                    // Check if time ran out
                    if (game.timer <= 0) {
                        game.timer = 0;
                        game.timerActive = false;
                        gameOver();
                    }
                }
                
                if (game.state === 'playing') {
                    updateRuler();
                    updateLeaderboard();
                }
                
                // Update HUD
                document.getElementById('heightDisplay').textContent = `Height: ${game.height}m`;
                document.getElementById('coinsDisplay').textContent = `ü™ô ${game.coins}`;
                
                // Update timer and checkpoint distance in solo mode
                if (game.mode === 'solo') {
                    const minutes = Math.floor(game.timer / 60);
                    const seconds = Math.floor(game.timer % 60);
                    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    const timerColor = game.timer < 10 ? '#ff6b6b' : '#4ecdc4';
                    
                    // Find next checkpoint
                    const nextCheckpoint = game.milestones.find(m => m > game.height);
                    const distanceToNext = nextCheckpoint ? nextCheckpoint - game.height : 0;
                    
                    if (nextCheckpoint) {
                        document.getElementById('heightDisplay').textContent = `‚è±Ô∏è ${timeStr} ‚Ä¢ ${game.height}m ‚Ä¢ ‚è±Ô∏è${distanceToNext}m`;
                    } else {
                        document.getElementById('heightDisplay').textContent = `‚è±Ô∏è ${timeStr} ‚Ä¢ ${game.height}m`;
                    }
                    document.getElementById('heightDisplay').style.color = timerColor;
                } else {
                    document.getElementById('heightDisplay').style.color = '#d4a78a';
                }
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        // Countdown for multiplayer start
        function startCountdown() {
            const countdownInterval = setInterval(() => {
                game.countdown--;
                
                if (game.countdown <= 0) {
                    clearInterval(countdownInterval);
                    game.raceStarted = true;
                    
                    // Enable all NPCs to start jumping (3x slower than before)
                    const now = Date.now();
                    for (let npc of game.npcs) {
                        npc.nextJumpTime = now + (Math.random() * 500 + 200) * 3;
                    }
                }
            }, 1000);
        }

        // Game controls
        game.startGame = function(mode = 'solo') {
            game.mode = mode;
            game.state = 'playing';
            game.height = 0;
            game.maxHeight = 0;
            game.coins = 0;
            game.particles = [];
            game.continued = false;
            game.player.skin = game.selectedSkin;
            game.player.powerPercent = 50;
            game.player.aimMode = false;
            game.lastMilestone = 0;
            game.checkpointsCollected = [];
            game.finishOrder = [];
            game.raceFinished = false;
            
            // Initialize timer/countdown based on mode
            if (mode === 'solo') {
                game.timer = 30 + game.activePowerUps.bonusTime; // Apply extra time power-up
                game.timerActive = true;
                game.countdown = 0;
                game.raceStarted = true;
            } else {
                // Multiplayer: Start with countdown
                game.timerActive = false;
                game.countdown = 3;
                game.raceStarted = false;
            }
            
            // Initialize NPCs for multiplayer
            if (mode === 'multiplayer') {
                initializeNPCs();
            } else {
                game.npcs = [];
            }
            
            generateHolds();
            
            // CRITICAL FIX: Force player to grounded state after generateHolds
            game.player.vx = 0;
            game.player.vy = 0;
            game.player.grounded = true;
            game.player.snapping = false;
            game.player.aimMode = false;
            
            document.getElementById('startScreen').classList.remove('active');
            document.getElementById('gameOverScreen').classList.remove('active');
            
            const skinsScreen = document.getElementById('skinsScreen');
            if (skinsScreen) {
                skinsScreen.classList.remove('active');
            }
            
            document.getElementById('powerBar').style.display = 'block';
            document.getElementById('instruction').style.display = 'block';
            
            // Reset power bar display
            document.getElementById('powerFill').style.width = '50%';
            document.getElementById('powerPercentage').textContent = '50%';
            
            // Show warp toggle button only if Konami code unlocked
            if (konamiUnlocked) {
                document.getElementById('warpToggle').style.display = 'block';
            } else {
                document.getElementById('warpToggle').style.display = 'none';
            }
            document.getElementById('warpUI').style.display = 'none';
            
            // Start countdown for multiplayer
            if (mode === 'multiplayer') {
                startCountdown();
            }
            
            setTimeout(() => {
                document.getElementById('instruction').style.display = 'none';
            }, 4000);
        };

        game.showStart = function() {
            game.state = 'start';
            document.getElementById('startScreen').classList.add('active');
            document.getElementById('gameOverScreen').classList.remove('active');
            document.getElementById('storeScreen').classList.remove('active');
            
            const skinsScreen = document.getElementById('skinsScreen');
            if (skinsScreen) {
                skinsScreen.classList.remove('active');
            }
            
            document.getElementById('powerBar').style.display = 'none';
            document.getElementById('warpToggle').style.display = 'none';
            document.getElementById('warpUI').style.display = 'none';
            document.getElementById('totalCoins').textContent = game.totalCoins;
        };
        
        // Warp functions
        game.toggleWarp = function() {
            const warpUI = document.getElementById('warpUI');
            const warpToggle = document.getElementById('warpToggle');
            
            if (warpUI.style.display === 'none' || warpUI.style.display === '') {
                warpUI.style.display = 'flex';
                warpToggle.style.display = 'none';
                document.getElementById('warpInput').focus();
            } else {
                warpUI.style.display = 'none';
                warpToggle.style.display = 'block';
            }
        };
        
        game.warpToAltitude = function() {
            const targetAltitude = parseInt(document.getElementById('warpInput').value);
            
            if (isNaN(targetAltitude) || targetAltitude < 0) {
                alert('Please enter a valid altitude (0 or higher)');
                return;
            }
            
            // Find closest hold to target altitude
            let closestHold = null;
            let closestDistance = Infinity;
            
            for (let hold of game.holds) {
                const holdAltitude = game.groundLevel - hold.y;
                const distance = Math.abs(holdAltitude - targetAltitude);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestHold = hold;
                }
            }
            
            if (closestHold) {
                // Teleport player to the hold
                game.player.x = closestHold.x;
                game.player.y = closestHold.y - 60; // Above the hold
                game.player.vy = 0;
                game.player.vx = 0;
                game.player.onHold = false;
                game.player.currentHold = closestHold;
                
                // Update camera
                game.camera.y = game.player.y - displayHeight / 2;
                
                // Update max height if warped higher
                const warpedHeight = game.groundLevel - game.player.y;
                if (warpedHeight > game.maxHeight) {
                    game.maxHeight = warpedHeight;
                }
                
                // Generate more holds if needed
                while (game.holds[game.holds.length - 1].y > game.player.y - displayHeight * 3) {
                    addHold();
                }
                
                // Close warp UI
                game.toggleWarp();
                
                // Visual feedback
                const actualAltitude = Math.floor(game.groundLevel - closestHold.y);
                document.getElementById('warpInput').value = '';
                
                // Flash effect
                const flash = document.createElement('div');
                flash.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(212, 160, 60, 0.3); pointer-events: none; z-index: 100;';
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 200);
            }
        };
        
        // Store functions
        game.showStore = function() {
            document.getElementById('startScreen').classList.remove('active');
            document.getElementById('storeScreen').classList.add('active');
            document.getElementById('storeCoins').textContent = game.totalCoins;
            game.showStoreTab('skins');
        };
        
        game.showStoreTab = function(tab) {
            const skinsTab = document.getElementById('skinsTab');
            const powerupsTab = document.getElementById('powerupsTab');
            const upgradesTab = document.getElementById('upgradesTab');
            
            // Reset all tab styles
            skinsTab.style.background = '#666';
            powerupsTab.style.background = '#666';
            upgradesTab.style.background = '#666';
            
            // Highlight active tab
            if (tab === 'skins') {
                skinsTab.style.background = '#8b7355';
                game.renderSkins();
            } else if (tab === 'powerups') {
                powerupsTab.style.background = '#8b7355';
                game.renderPowerUps();
            } else {
                upgradesTab.style.background = '#8b7355';
                game.renderUpgrades();
            }
        };
        
        game.renderSkins = function() {
            const storeContent = document.getElementById('storeContent');
            let html = '';
            
            // Group skins by category
            const categories = ['Starter', 'Animals', 'Heroes', 'Villains', 'Fantasy', 'Robots', 'Legendary'];
            
            for (let category of categories) {
                const categorySkins = Object.entries(skins).filter(([key, skin]) => skin.category === category);
                if (categorySkins.length === 0) continue;
                
                html += `<div style="margin-bottom: 25px;">`;
                html += `<h3 style="color: #ffd700; text-align: center; margin-bottom: 15px; font-size: 20px;">${category} Collection</h3>`;
                html += `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px;">`;
                
                for (let [key, skin] of categorySkins) {
                    const owned = game.ownedSkins.includes(key);
                    const equipped = game.selectedSkin === key;
                    const canAfford = game.totalCoins >= skin.cost;
                    
                    let buttonStyle = '';
                    let buttonText = '';
                    let onclick = '';
                    
                    if (equipped) {
                        buttonStyle = 'background: #2ecc71; border: 1px solid rgba(0,0,0,0.15); border-bottom: 2px solid rgba(0,0,0,0.25); color: #fff; cursor: default; font-weight: 600;';
                        buttonText = '‚úì EQUIPPED';
                        onclick = '';
                    } else if (owned) {
                        buttonStyle = 'background: #3498db; border: 1px solid rgba(0,0,0,0.15); border-bottom: 2px solid rgba(0,0,0,0.25); color: #fff; font-weight: 600;';
                        buttonText = 'EQUIP';
                        onclick = `onclick="game.equipSkin('${key}')"`;
                    } else if (canAfford) {
                        buttonStyle = 'background: #ffd700; border: 1px solid rgba(0,0,0,0.15); border-bottom: 2px solid rgba(0,0,0,0.25); color: #000; font-weight: 700;';
                        buttonText = `BUY ${skin.cost.toLocaleString()}ü™ô`;
                        onclick = `onclick="game.buySkin('${key}')"`;
                    } else {
                        buttonStyle = 'background: rgba(80,80,80,0.5); border: 1px solid rgba(0,0,0,0.2); color: rgba(180,180,180,0.7); cursor: not-allowed; font-weight: 600;';
                        buttonText = `${skin.cost.toLocaleString()}ü™ô`;
                        onclick = '';
                    }
                    
                    const borderColor = skin.colors?.primary || '#8b7355';
                    const canvasId = `skin-preview-${key}`;
                    
                    html += `
                        <div style="background: rgba(20,20,20,0.75); padding: 14px; text-align: center; border: 1px solid rgba(${borderColor === '#8b7355' ? '139,115,85' : '100,100,100'},0.4); border-bottom: 2px solid rgba(${borderColor === '#8b7355' ? '139,115,85' : '100,100,100'},0.5); border-radius: 8px;">
                            <canvas id="${canvasId}" width="80" height="80" style="display: block; margin: 0 auto 10px;"></canvas>
                            <div style="color: rgba(255,255,255,0.95); font-weight: 700; font-size: 14px; margin-bottom: 5px; min-height: 32px; display: flex; align-items: center; justify-content: center; letter-spacing: 0.2px;">${skin.name}</div>
                            <div style="color: rgba(212,167,138,0.8); font-size: 11px; margin-bottom: 12px; min-height: 30px; font-weight: 500; line-height: 1.3;">${skin.description}</div>
                            <button ${onclick} style="padding: 9px 12px; font-size: 12px; width: 100%; ${buttonStyle} cursor: pointer; letter-spacing: 0.3px; transition: all 0.15s ease; border-radius: 6px;">${buttonText}</button>
                        </div>
                    `;
                }
                
                html += `</div></div>`;
            }
            
            storeContent.innerHTML = html;
            
            // Draw character previews on canvases
            for (let category of categories) {
                const categorySkins = Object.entries(skins).filter(([key, skin]) => skin.category === category);
                for (let [key, skin] of categorySkins) {
                    const canvas = document.getElementById(`skin-preview-${key}`);
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, 80, 80);
                        
                        // Draw background
                        ctx.fillStyle = 'rgba(40, 30, 20, 0.5)';
                        ctx.fillRect(0, 0, 80, 80);
                        
                        // Draw character centered
                        ctx.save();
                        ctx.translate(40, 40);
                        
                        // Create a mock player object for drawing
                        const mockPlayer = {
                            radius: 20,
                            armAnimation: 0,
                            legAnimation: 0
                        };
                        
                        drawCharacter(ctx, skin, mockPlayer);
                        ctx.restore();
                    }
                }
            }
        };
        
        game.renderPowerUps = function() {
            const storeContent = document.getElementById('storeContent');
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">';
            
            for (let [key, powerUp] of Object.entries(powerUps)) {
                const canAfford = game.totalCoins >= powerUp.cost;
                const buttonStyle = canAfford 
                    ? 'background: #ffd700; border: 1px solid rgba(0,0,0,0.15); border-bottom: 2px solid rgba(0,0,0,0.25); color: #000; font-weight: 700;'
                    : 'background: rgba(80,80,80,0.5); border: 1px solid rgba(0,0,0,0.2); color: rgba(180,180,180,0.7); cursor: not-allowed; font-weight: 600;';
                const onclick = canAfford ? `onclick="game.buyPowerUp('${key}')"` : '';
                
                html += `
                    <div style="background: rgba(20,20,20,0.75); padding: 22px 18px; text-align: center; border: 1px solid rgba(139,115,85,0.3); border-bottom: 2px solid rgba(139,115,85,0.4); border-radius: 10px;">
                        <div style="font-size: 52px; margin-bottom: 12px;">${powerUp.icon}</div>
                        <div style="color: rgba(255,215,0,0.95); font-weight: 700; font-size: 17px; margin-bottom: 6px; letter-spacing: 0.3px;">${powerUp.name}</div>
                        <div style="color: rgba(212,167,138,0.85); font-size: 13px; margin-bottom: 16px; min-height: 40px; line-height: 1.4; font-weight: 500;">${powerUp.description}</div>
                        <button ${onclick} style="padding: 11px 16px; font-size: 13px; width: 100%; ${buttonStyle} cursor: pointer; letter-spacing: 0.4px; transition: all 0.15s ease; border-radius: 6px;">
                            BUY ${powerUp.cost.toLocaleString()}ü™ô
                        </button>
                    </div>
                `;
            }
            
            html += '</div>';
            storeContent.innerHTML = html;
        };
        
        game.renderUpgrades = function() {
            const storeContent = document.getElementById('storeContent');
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">';
            
            for (let [key, upgrade] of Object.entries(upgrades)) {
                const owned = game.ownedUpgrades.includes(key);
                const canAfford = game.totalCoins >= upgrade.cost;
                const meetsRequirements = !upgrade.requires || game.ownedUpgrades.includes(upgrade.requires);
                
                let buttonStyle = '';
                let buttonText = '';
                let onclick = '';
                let borderColor = 'rgba(139,115,85,0.4)';
                
                if (owned) {
                    buttonStyle = 'background: #2ecc71; border: 1px solid rgba(0,0,0,0.15); border-bottom: 2px solid rgba(0,0,0,0.25); color: #fff; cursor: default; font-weight: 600;';
                    buttonText = '‚úì OWNED';
                    onclick = '';
                    borderColor = 'rgba(46,204,113,0.5)';
                } else if (!meetsRequirements) {
                    buttonStyle = 'background: rgba(60,60,60,0.5); border: 1px solid rgba(0,0,0,0.2); color: rgba(150,150,150,0.7); cursor: not-allowed; font-weight: 600;';
                    buttonText = `üîí LOCKED`;
                    onclick = '';
                } else if (canAfford) {
                    buttonStyle = 'background: #ffd700; border: 1px solid rgba(0,0,0,0.15); border-bottom: 2px solid rgba(0,0,0,0.25); color: #000; font-weight: 700;';
                    buttonText = `BUY ${upgrade.cost.toLocaleString()}ü™ô`;
                    onclick = `onclick="game.buyUpgrade('${key}')"`;
                } else {
                    buttonStyle = 'background: rgba(80,80,80,0.5); border: 1px solid rgba(0,0,0,0.2); color: rgba(180,180,180,0.7); cursor: not-allowed; font-weight: 600;';
                    buttonText = `${upgrade.cost.toLocaleString()}ü™ô`;
                    onclick = '';
                }
                
                const requiresText = upgrade.requires ? `<div style="color: rgba(231,76,60,0.9); font-size: 11px; margin-top: 6px; font-weight: 500;">üîí ${upgrades[upgrade.requires]?.name}</div>` : '';
                const stackInfo = upgrade.stackable && upgrade.stackInfo ? `<div style="color: rgba(52,152,219,0.9); font-size: 10px; margin-top: 4px; font-weight: 500;">‚ÜóÔ∏è ${upgrade.stackInfo}</div>` : '';
                
                html += `
                    <div style="background: rgba(20,20,20,0.75); padding: 22px 18px; text-align: center; border: 1px solid ${borderColor}; border-bottom: 2px solid ${borderColor}; border-radius: 10px;">
                        <div style="font-size: 52px; margin-bottom: 12px;">${upgrade.icon}</div>
                        <div style="color: rgba(255,215,0,0.95); font-weight: 700; font-size: 17px; margin-bottom: 6px; letter-spacing: 0.3px;">${upgrade.name}</div>
                        <div style="color: rgba(212,167,138,0.85); font-size: 13px; margin-bottom: 10px; min-height: 40px; line-height: 1.4; font-weight: 500;">${upgrade.description}</div>
                        ${requiresText}
                        ${stackInfo}
                        <button ${onclick} style="padding: 11px 16px; font-size: 13px; width: 100%; margin-top: 12px; ${buttonStyle} cursor: pointer; letter-spacing: 0.4px; transition: all 0.15s ease; border-radius: 6px;">
                            ${buttonText}
                        </button>
                    </div>
                `;
            }
            
            html += '</div>';
            storeContent.innerHTML = html;
        };
        
        game.buySkin = function(skinKey) {
            const skin = skins[skinKey];
            if (game.totalCoins >= skin.cost) {
                game.totalCoins -= skin.cost;
                game.ownedSkins.push(skinKey);
                localStorage.setItem('climberCoins', game.totalCoins);
                localStorage.setItem('ownedSkins', JSON.stringify(game.ownedSkins));
                document.getElementById('storeCoins').textContent = game.totalCoins;
                game.renderSkins();
            }
        };
        
        game.equipSkin = function(skinKey) {
            game.selectedSkin = skinKey;
            game.player.skin = skinKey;
            localStorage.setItem('selectedSkin', skinKey);
            game.renderSkins();
        };
        
        game.buyPowerUp = function(powerUpKey) {
            const powerUp = powerUps[powerUpKey];
            if (game.totalCoins >= powerUp.cost) {
                game.totalCoins -= powerUp.cost;
                localStorage.setItem('climberCoins', game.totalCoins);
                document.getElementById('storeCoins').textContent = game.totalCoins;
                
                // Activate power-up
                game.activePowerUps[powerUp.effect] = true;
                if (powerUp.effect === 'coinMultiplier') game.activePowerUps.coinMultiplier = 2;
                if (powerUp.effect === 'bonusTime') game.activePowerUps.bonusTime = 30;
                
                alert(`${powerUp.icon} ${powerUp.name} activated! Will be used in your next game.`);
                game.renderPowerUps();
            }
        };
        
        game.buyUpgrade = function(upgradeKey) {
            const upgrade = upgrades[upgradeKey];
            const meetsRequirements = !upgrade.requires || game.ownedUpgrades.includes(upgrade.requires);
            
            if (game.totalCoins >= upgrade.cost && meetsRequirements && !game.ownedUpgrades.includes(upgradeKey)) {
                game.totalCoins -= upgrade.cost;
                game.ownedUpgrades.push(upgradeKey);
                localStorage.setItem('climberCoins', game.totalCoins);
                localStorage.setItem('ownedUpgrades', JSON.stringify(game.ownedUpgrades));
                document.getElementById('storeCoins').textContent = game.totalCoins;
                
                alert(`${upgrade.icon} ${upgrade.name} purchased! This permanent upgrade is now active.`);
                game.renderUpgrades();
            }
        };

        game.showSkins = function() {
            const skinsScreen = document.getElementById('skinsScreen');
            if (!skinsScreen) {
                console.warn('Skins screen not available in this version');
                return;
            }
            
            document.getElementById('startScreen').classList.remove('active');
            skinsScreen.classList.add('active');
            
            const skinsCoins = document.getElementById('skinsCoins');
            if (skinsCoins) {
                skinsCoins.textContent = game.totalCoins;
            }
            
            if (typeof renderSkins === 'function') {
                renderSkins();
            }
        };

        game.watchAdToContinue = function() {
            if (game.continued) return;
            
            // Simulate ad
            alert('üì∫ Ad would play here!\n\nIn production, integrate AdMob or similar.');
            
            // Continue game
            game.continued = true;
            game.state = 'playing';
            document.getElementById('gameOverScreen').classList.remove('active');
            document.getElementById('powerBar').style.display = 'block';
            
            // Reset power
            game.player.powerPercent = 50;
            game.player.aimMode = false;
            document.getElementById('powerFill').style.width = '50%';
            document.getElementById('powerPercentage').textContent = '50%';
            
            // Place player on nearest hold
            let nearestHold = game.holds[0];
            let minDist = Infinity;
            
            for (let hold of game.holds) {
                if (hold.broken) continue;
                const dist = Math.abs(hold.y - game.player.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearestHold = hold;
                }
            }
            
            game.player.x = nearestHold.x;
            game.player.y = nearestHold.y - nearestHold.height / 2 - game.player.radius;
            game.player.grounded = true;
            game.player.vx = 0;
            game.player.vy = 0;
        };

        function gameOver() {
            if (game.state !== 'playing') return;
            
            game.state = 'gameOver';
            game.totalCoins += game.coins;
            localStorage.setItem('climberCoins', game.totalCoins);
            
            vibrate(50);
            
            document.getElementById('powerBar').style.display = 'none';
            document.getElementById('finalHeight').textContent = game.maxHeight;
            document.getElementById('earnedCoins').textContent = game.coins;
            document.getElementById('gameOverScreen').classList.add('active');
        }

        function showCombo() {
            if (game.combo < 2) return;
            
            const comboEl = document.createElement('div');
            comboEl.className = 'combo';
            comboEl.textContent = `${game.combo}x COMBO!`;
            document.body.appendChild(comboEl);
            
            setTimeout(() => {
                comboEl.remove();
            }, 800);
        }

        function renderSkins() {
            const grid = document.getElementById('skinsGrid');
            if (!grid) return; // Element doesn't exist, skip
            
            grid.innerHTML = '';
            
            for (let [key, skin] of Object.entries(skins)) {
                const isUnlocked = game.unlockedSkins.includes(key);
                const isSelected = game.selectedSkin === key;
                
                const card = document.createElement('div');
                card.className = 'skin-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' locked' : '');
                
                const preview = document.createElement('div');
                preview.className = 'skin-preview';
                preview.style.background = skin.color;
                
                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = skin.name;
                
                const cost = document.createElement('div');
                cost.className = 'skin-cost';
                cost.textContent = isUnlocked ? (isSelected ? '‚úì EQUIPPED' : 'OWNED') : `ü™ô ${skin.cost}`;
                
                card.appendChild(preview);
                card.appendChild(name);
                card.appendChild(cost);
                
                card.onclick = () => {
                    if (isUnlocked) {
                        game.selectedSkin = key;
                        localStorage.setItem('climberSelectedSkin', key);
                        renderSkins();
                    } else {
                        if (game.totalCoins >= skin.cost) {
                            game.totalCoins -= skin.cost;
                            game.unlockedSkins.push(key);
                            game.selectedSkin = key;
                            localStorage.setItem('climberCoins', game.totalCoins);
                            localStorage.setItem('climberSkins', JSON.stringify(game.unlockedSkins));
                            localStorage.setItem('climberSelectedSkin', key);
                            document.getElementById('skinsCoins').textContent = game.totalCoins;
                            renderSkins();
                            vibrate(30);
                        } else {
                            alert(`Need ${skin.cost - game.totalCoins} more coins!`);
                        }
                    }
                };
                
                grid.appendChild(card);
            }
        }

        function vibrate(duration) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }

        // Initialize game state BEFORE starting game loop
        game.groundLevel = displayHeight - 100;
        generateHolds(); // Generate holds so they show on start screen
        
        // Start game loop
        gameLoop();
        
        // Initialize UI
        document.getElementById('totalCoins').textContent = game.totalCoins;
        
        // Hide loading screen (background already rendered immediately after canvas setup)
        setTimeout(() => {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
            }
        }, 500);
        
        console.log('Mountain Climber - Mobile Optimized Ready!');
        
        }); // End DOMContentLoaded
    </script>
</body>
</html>
