<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Mountain Climber - Race to the Summit!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            min-height: 100vh;
            min-height: calc(var(--vh, 1vh) * 100);
            min-height: -webkit-fill-available;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: #87ceeb;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            width: 100%;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            cursor: pointer;
            touch-action: none;
        }

        /* HUD Elements - Mobile Optimized */
        .hud {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: 10px;
            right: 10px;
            z-index: 5;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
        }

        .hud-left, .hud-right {
            background: rgba(40, 30, 20, 0.9);
            padding: 12px 16px;
            border-radius: 12px;
            color: #fff;
            font-weight: bold;
            font-size: clamp(14px, 4vw, 18px);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(139, 115, 85, 0.6);
        }

        .power-bar {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 20px);
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            z-index: 5;
            display: none;
        }

        .power-bar-label {
            text-align: center;
            color: #fff;
            font-weight: bold;
            font-size: clamp(12px, 3.5vw, 16px);
            margin-bottom: 8px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9);
            letter-spacing: 1px;
        }

        .power-bar-container {
            width: 100%;
            height: 50px;
            background: linear-gradient(135deg, rgba(40, 30, 20, 0.95) 0%, rgba(60, 45, 30, 0.95) 100%);
            border-radius: 25px;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 3px solid rgba(139, 90, 43, 0.7);
            position: relative;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .power-fill {
            height: 100%;
            background: linear-gradient(90deg, #6b8e23 0%, #8b7355 50%, #d4a574 100%);
            transition: width 0.1s;
            position: relative;
            box-shadow: inset 0 2px 8px rgba(255, 255, 255, 0.2);
        }

        .power-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-weight: bold;
            font-size: clamp(18px, 5vw, 24px);
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9);
            pointer-events: none;
            z-index: 2;
        }

        .instruction {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 100px);
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: clamp(12px, 3.5vw, 16px);
            text-align: center;
            z-index: 5;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9);
            max-width: 90%;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            display: none;
        }

        /* Height Ruler - Mobile Optimized */
        .height-ruler {
            position: absolute;
            left: 10px;
            top: calc(env(safe-area-inset-top, 10px) + 80px);
            bottom: calc(env(safe-area-inset-bottom, 20px) + 120px);
            width: 50px;
            background: rgba(40, 30, 20, 0.85);
            border-radius: 8px;
            z-index: 4;
            border: 2px solid rgba(139, 115, 85, 0.6);
            overflow: hidden;
            display: none;
        }

        .ruler-bg {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .ruler-marker {
            position: absolute;
            width: 100%;
            height: 2px;
            background: rgba(139, 115, 85, 0.5);
            left: 0;
        }

        .ruler-text {
            position: absolute;
            left: 55px;
            font-size: 11px;
            color: #d4a78a;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9);
            white-space: nowrap;
        }

        /* Leaderboard - Mobile Optimized */
        #leaderboard {
            position: absolute;
            top: calc(env(safe-area-inset-top, 10px) + 10px);
            right: 10px;
            background: rgba(40, 30, 20, 0.95);
            padding: 12px 16px;
            border-radius: 12px;
            border: 2px solid rgba(139, 115, 85, 0.8);
            min-width: 160px;
            max-width: 200px;
            backdrop-filter: blur(10px);
            z-index: 10;
            display: none;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
        }

        /* Screens - Mobile Optimized */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(139, 115, 85, 0.98) 0%, rgba(101, 67, 33, 0.98) 100%);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            padding: env(safe-area-inset-top, 20px) env(safe-area-inset-right, 20px) env(safe-area-inset-bottom, 20px) env(safe-area-inset-left, 20px);
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
        }

        .title {
            font-size: clamp(32px, 10vw, 56px);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.9);
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.2;
        }

        .subtitle {
            font-size: clamp(14px, 4vw, 20px);
            color: #d4a78a;
            margin-bottom: 30px;
            text-align: center;
        }

        .btn {
            padding: clamp(12px, 3vw, 18px) clamp(24px, 6vw, 40px);
            margin: 8px;
            font-size: clamp(16px, 4.5vw, 22px);
            font-weight: bold;
            color: #fff;
            background: linear-gradient(135deg, #8b7355, #d4a78a);
            border: 3px solid #654321;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            min-width: 200px;
            max-width: 90%;
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #a78bfa, #ff9a56);
            border-color: #7c3aed;
        }

        .coins-display {
            font-size: clamp(18px, 5vw, 24px);
            color: #ffd700;
            font-weight: bold;
            margin-top: 20px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9);
        }

        .score-display {
            font-size: clamp(24px, 6vw, 36px);
            color: #fff;
            font-weight: bold;
            margin: 20px 0;
            text-shadow: 0 3px 8px rgba(0, 0, 0, 0.9);
        }

        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #8b7355, #654321);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: #fff;
            font-size: clamp(20px, 5vw, 28px);
            font-weight: bold;
            margin-top: 20px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="spinner"></div>
        <div class="loading-text">‚õ∞Ô∏è Loading Mountain Climber...</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div class="hud">
        <div class="hud-left" id="heightDisplay">Height: 0m</div>
        <div class="hud-right" id="coinsDisplay">ü™ô 0</div>
    </div>

    <div class="height-ruler" id="heightRuler">
        <div class="ruler-bg" id="rulerBg"></div>
    </div>

    <!-- Multiplayer Leaderboard -->
    <div id="leaderboard">
        <div style="color: #ffd700; font-weight: bold; font-size: clamp(14px, 4vw, 16px); margin-bottom: 10px; text-align: center; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9);">üèÜ RACE</div>
        <div id="leaderboardList"></div>
    </div>

    <div class="power-bar" id="powerBar">
        <div class="power-bar-label">JUMP POWER</div>
        <div class="power-bar-container" id="powerBarContainer">
            <div class="power-fill" id="powerFill"></div>
            <div class="power-percentage" id="powerPercentage">50%</div>
        </div>
    </div>
    <div class="instruction" id="instruction">TAP POWER BAR ‚Ä¢ DRAG TO AIM ‚Ä¢ RELEASE TO JUMP</div>

    <!-- Start Screen -->
    <div class="screen active" id="startScreen">
        <div class="title">‚õ∞Ô∏è MOUNTAIN<br>CLIMBER</div>
        <div class="subtitle">Race to the Summit!</div>
        <button class="btn" onclick="startGame('solo')">üßó SOLO CLIMB</button>
        <button class="btn" onclick="startGame('multiplayer')" style="background: linear-gradient(135deg, #6b8e23, #95e1d3); border-color: #4a5f1e;">üë• MULTIPLAYER</button>
        <div class="coins-display">ü™ô <span id="totalCoins">0</span></div>
    </div>

    <!-- Game Over Screen -->
    <div class="screen" id="gameOverScreen">
        <div class="title">‚õ∞Ô∏è TIME'S UP!</div>
        <div class="score-display">Height: <span id="finalHeight">0</span>m</div>
        <div class="coins-display">+<span id="earnedCoins">0</span> ü™ô</div>
        <button class="btn" onclick="startGame('solo')">CLIMB AGAIN</button>
        <button class="btn btn-secondary" onclick="showStart()">MENU</button>
    </div>

    <script>
        // Global game object (will be initialized when DOM loads)
        let game;
        
        // Global function wrappers for button onclick handlers
        function startGame(mode) {
            if (game && game.startGame) {
                game.startGame(mode);
            }
        }
        
        function showStart() {
            if (game && game.showStart) {
                game.showStart();
            }
        }
        
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Perfect screen-filling canvas with aspect ratio handling
        function resizeCanvas() {
            // Fix for mobile browsers (address bar compensation)
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            
            // Get actual viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;
            
            // Set display size (CSS pixels)
            canvas.style.width = viewportWidth + 'px';
            canvas.style.height = viewportHeight + 'px';
            
            // Set actual canvas size (accounting for DPI)
            canvas.width = viewportWidth * dpr;
            canvas.height = viewportHeight * dpr;
            
            // Scale context to match DPI
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
            ctx.scale(dpr, dpr);
            
            // Update game ground level if it exists
            if (game && game.groundLevel !== undefined) {
                game.groundLevel = viewportHeight - 100;
            }
            
            console.log(`Canvas resized: ${viewportWidth}x${viewportHeight} @ ${dpr}x DPI`);
        }
        
        // Initial resize
        resizeCanvas();
        
        // Handle window resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                resizeCanvas();
                if (game && game.state === 'playing') {
                    updateRuler();
                }
            }, 100);
        });
        
        // Handle orientation change (mobile)
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                resizeCanvas();
                if (game && game.state === 'playing') {
                    updateRuler();
                }
            }, 200);
        });

        // Game state
        // Initialize the global game object
        game = {
            state: 'start', // start, playing, gameOver, victory
            mode: 'solo', // solo or multiplayer
            npcs: [], // NPC climbers in multiplayer
            timer: 60, // 60 seconds starting time for solo mode
            timerActive: false,
            player: {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                radius: 15,
                currentHold: null,
                powerPercent: 50,
                lastJumpPowerPercent: 50, // Track power used in last jump for breakable holds
                aimMode: false,
                aimStartX: 0,
                aimStartY: 0,
                aimCurrentX: 0,
                aimCurrentY: 0,
                skin: 'default',
                grounded: false,
                snapping: false,
                snapProgress: 0,
                rotation: 0,
                targetRotation: 0,
                armAnimation: 0,
                legAnimation: 0,
                jumpBoost: 1.0, // Dynamic multiplier for unreachable situations
                reachableHolds: [],
                celebrating: false,
                celebrationTime: 0,
                name: 'YOU'
            },
            camera: {
                y: 0,
                targetY: 0
            },
            holds: [],
            particles: [],
            decorations: [], // shrubs, goats, etc.
            height: 0,
            maxHeight: 0,
            coins: 0,
            totalCoins: parseInt(localStorage.getItem('climberCoins') || '0'),
            difficulty: 1,
            holdSpacing: 150,
            lastHoldY: 0,
            continued: false,
            unlockedSkins: JSON.parse(localStorage.getItem('climberSkins') || '["default"]'),
            selectedSkin: localStorage.getItem('climberSelectedSkin') || 'default',
            groundLevel: 0,
            lastMilestone: 0,
            milestones: [], // Will be calculated dynamically
            checkpointsCollected: [], // Track which checkpoints have been collected
            winThreshold: 500,
            completedRuns: 0,
            milestoneFlags: [],
            time: 0
        };

        // Generate progressive milestones: 250m intervals (x3), 300m (x3), 350m (x3), 400m (x3), etc.
        function generateMilestones() {
            const milestones = [];
            let currentHeight = 0;
            let interval = 250;
            let intervalCount = 0;
            const intervalsPerStep = 3;
            
            for (let i = 0; i < 30; i++) { // Generate 30 milestones
                currentHeight += interval;
                milestones.push(currentHeight);
                
                intervalCount++;
                if (intervalCount >= intervalsPerStep) {
                    interval += 50; // Increase interval by 50m every 3 milestones
                    intervalCount = 0;
                }
            }
            
            return milestones;
        }

        game.milestones = generateMilestones();
        console.log('Milestones:', game.milestones);

        // Skin definitions
        const skins = {
            default: { name: 'Classic', color: '#ff6b6b', cost: 0 },
            blue: { name: 'Arctic', color: '#4ecdc4', cost: 100 },
            yellow: { name: 'Sunshine', color: '#ffe66d', cost: 250 },
            green: { name: 'Forest', color: '#95e1d3', cost: 500 },
            purple: { name: 'Summit', color: '#a78bfa', cost: 750 },
            orange: { name: 'Volcano', color: '#ff9a56', cost: 1000 }
        };

        // Helper function to get cliff bounds at any Y position
        function getCliffBounds(y) {
            const baseCliffWidth = canvas.width * 0.6;
            const cliffCenterX = canvas.width / 2;
            
            // Smaller, more realistic variations for actual cliff face
            const leftVariation = Math.sin(y * 0.002) * 40 + 
                                 Math.sin(y * 0.008) * 20 + 
                                 Math.cos(y * 0.015) * 10;
            const rightVariation = Math.sin(y * 0.002 + Math.PI) * 40 + 
                                  Math.cos(y * 0.008 + 1) * 20 + 
                                  Math.sin(y * 0.015 + 2) * 10;
            
            return {
                left: cliffCenterX - baseCliffWidth / 2 + leftVariation,
                right: cliffCenterX + baseCliffWidth / 2 + rightVariation,
                center: cliffCenterX
            };
        }

        // Generate initial holds
        function generateHolds() {
            game.holds = [];
            game.decorations = [];
            game.milestoneFlags = [];
            game.groundLevel = canvas.height - 100;
            game.lastHoldY = game.groundLevel;
            game.lastMilestone = 0;
            
            // Starting hold at ground level
            game.holds.push({
                x: canvas.width / 2,
                y: game.groundLevel,
                width: 35,
                height: 20,
                type: 'normal',
                moving: false,
                visited: false,
                lastLeftTime: 0
            });

            // Generate holds upward
            for (let i = 0; i < 30; i++) {
                addHold();
            }
            
            // Generate decorations
            for (let i = 0; i < 20; i++) {
                addDecoration();
            }

            // Set player above first hold
            game.player.x = canvas.width / 2;
            game.player.y = game.groundLevel - 60;
            game.player.currentHold = game.holds[0];
            game.player.grounded = true;
            game.player.snapping = false;
        }

        function addDecoration() {
            const y = game.lastHoldY - Math.random() * 300;
            const type = Math.random();
            
            let decoration;
            if (type < 0.6) {
                // Shrub
                decoration = {
                    type: 'shrub',
                    x: Math.random() * canvas.width,
                    y: y,
                    size: 20 + Math.random() * 30
                };
            } else if (type < 0.85) {
                // Small tree
                decoration = {
                    type: 'tree',
                    x: Math.random() * canvas.width,
                    y: y,
                    size: 40 + Math.random() * 40
                };
            } else {
                // Goat
                decoration = {
                    type: 'goat',
                    x: Math.random() * canvas.width,
                    y: y,
                    size: 25 + Math.random() * 15,
                    facingRight: Math.random() > 0.5
                };
            }
            
            game.decorations.push(decoration);
        }

        function addHold() {
            game.lastHoldY -= game.holdSpacing * (0.8 + Math.random() * 0.4);
            
            // Get cliff bounds at this Y position
            const bounds = getCliffBounds(game.lastHoldY);
            const cliffWidth = bounds.right - bounds.left;
            
            // Spawn hold within safe cliff bounds (with margin)
            const margin = 60;
            const minX = bounds.left + margin;
            const maxX = bounds.right - margin;
            const x = minX + Math.random() * (maxX - minX);
            
            // Increase difficulty over time
            const heightFactor = Math.abs(game.lastHoldY - game.groundLevel) / 1000;
            game.difficulty = 1 + heightFactor * 0.5;
            
            // Calculate height in meters
            const heightMeters = Math.abs(game.lastHoldY - game.groundLevel) / 10;
            
            let type = 'normal';
            let moving = false;
            let breakable = false;
            let width = 30 + Math.random() * 20;
            let height = 15 + Math.random() * 10;
            
            // Only allow moving holds after 150m
            if (heightMeters >= 150 && Math.random() < Math.min(0.3, heightFactor * 0.1)) {
                moving = true;
            }
            if (Math.random() < Math.min(0.2, heightFactor * 0.08)) {
                breakable = true;
            }
            if (Math.random() < Math.min(0.25, heightFactor * 0.1)) {
                width *= 0.7;
                height *= 0.7;
            }
            
            game.holds.push({
                x: x,
                y: game.lastHoldY,
                width: width,
                height: height,
                type: type,
                moving: moving,
                moveSpeed: moving ? (1 + Math.random() * 2) : 0,
                moveDir: Math.random() < 0.5 ? -1 : 1,
                moveRangeLeft: minX,
                moveRangeRight: maxX,
                breakable: breakable,
                broken: false,
                visited: false,
                lastLeftTime: 0 // Track when player last left this hold
            });
            
            // Add decoration near some holds
            if (Math.random() < 0.3) {
                addDecoration();
            }
        }

        // Physics
        function updatePlayer(dt) {
            // Update animations
            game.player.armAnimation += dt * 3;
            game.player.legAnimation += dt * 4;
            
            // Handle victory celebration
            if (game.player.celebrating) {
                game.player.celebrationTime += dt;
                // Jump celebration animation
                game.player.armAnimation += dt * 8;
                return;
            }
            
            // Smooth rotation
            game.player.rotation += (game.player.targetRotation - game.player.rotation) * 0.1;
            
            // Continuously analyze reachable holds when grounded
            if (game.player.grounded && game.state === 'playing') {
                analyzeReachableHolds();
            }
            
            // Handle smooth snapping
            if (game.player.snapping && game.player.currentHold) {
                game.player.snapProgress += dt * 8; // Snap speed
                
                if (game.player.snapProgress >= 1) {
                    // Snap complete
                    game.player.snapping = false;
                    game.player.grounded = true;
                    game.player.vx = 0;
                    game.player.vy = 0;
                    game.player.x = game.player.currentHold.x;
                    game.player.y = game.player.currentHold.y - game.player.currentHold.height / 2 - game.player.radius;
                    game.player.targetRotation = 0;
                    
                    // Award coin only once per hold
                    if (!game.player.currentHold.visited) {
                        game.player.currentHold.visited = true;
                        game.coins++;
                        createCoinParticles(game.player.currentHold.x, game.player.currentHold.y);
                        vibrate(10);
                    }
                } else {
                    // Lerp to hold position
                    const targetX = game.player.currentHold.x;
                    const targetY = game.player.currentHold.y - game.player.currentHold.height / 2 - game.player.radius;
                    game.player.x += (targetX - game.player.x) * game.player.snapProgress;
                    game.player.y += (targetY - game.player.y) * game.player.snapProgress;
                }
                return;
            }
            
            // If grounded on a moving hold, move with it
            if (game.player.grounded && game.player.currentHold && game.player.currentHold.moving) {
                game.player.x = game.player.currentHold.x;
                game.player.y = game.player.currentHold.y - game.player.currentHold.height / 2 - game.player.radius;
            }
            
            // Normal physics when not snapping and not grounded
            if (!game.player.grounded) {
                // Apply gravity
                game.player.vy += 1500 * dt;
                
                // Update position
                game.player.x += game.player.vx * dt;
                game.player.y += game.player.vy * dt;
                
                // Rotate while airborne
                game.player.targetRotation = Math.atan2(game.player.vy, game.player.vx);
                
                // Calculate current velocity magnitude for impact detection
                const currentSpeed = Math.sqrt(game.player.vx * game.player.vx + game.player.vy * game.player.vy);
                const currentTime = Date.now();
                const COOLDOWN_MS = 500; // 500ms cooldown before can re-snap to same hold
                
                // Check collision with holds - ANY contact triggers snap or break
                for (let hold of game.holds) {
                    if (hold.broken) continue;
                    
                    // Check cooldown - skip if recently left this hold
                    const timeSinceLeft = currentTime - hold.lastLeftTime;
                    if (timeSinceLeft < COOLDOWN_MS) {
                        continue; // Skip this hold, still on cooldown
                    }
                    
                    const dx = game.player.x - hold.x;
                    const dy = game.player.y - hold.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if player is within collision radius (any contact)
                    const collisionDist = game.player.radius + Math.max(hold.width / 2, hold.height / 2);
                    
                    if (dist < collisionDist) {
                        // Calculate impact velocity - velocity component toward the hold
                        const holdDx = hold.x - game.player.x;
                        const holdDy = hold.y - game.player.y;
                        const holdDist = Math.sqrt(holdDx * holdDx + holdDy * holdDy);
                        
                        // Normalize direction to hold
                        const dirX = holdDx / holdDist;
                        const dirY = holdDy / holdDist;
                        
                        // Project velocity onto direction to hold (dot product)
                        const impactVelocity = game.player.vx * dirX + game.player.vy * dirY;
                        
                        // Only count impacts when moving toward the hold (positive dot product)
                        // Convert to m/s: 1 pixel = 0.01m, so multiply by 100 to get m/s
                        const impactSpeedMS = Math.abs(impactVelocity);
                        
                        // Check if impact is too hard (50 m/s threshold = 5000 pixels/s)
                        const breakThreshold = 5000; // 50 m/s in pixels/s
                        
                        if (impactSpeedMS > breakThreshold && impactVelocity > 0) {
                            // Impact too hard - break the hold immediately
                            hold.broken = true;
                            createBreakParticles(hold.x, hold.y);
                            createImpactEffect(hold.x, hold.y, impactSpeedMS);
                            vibrate(50);
                            
                            // Bounce player off slightly
                            game.player.vx *= 0.3;
                            game.player.vy *= 0.3;
                            
                            continue; // Don't snap to this hold, keep falling
                        }
                        
                        // Normal landing - start smooth snap
                        game.player.currentHold = hold;
                        game.player.snapping = true;
                        game.player.snapProgress = 0;
                        
                        // Break if breakable AND jumped with >80% power
                        if (hold.breakable && game.player.lastJumpPowerPercent > 80) {
                            setTimeout(() => {
                                hold.broken = true;
                                createBreakParticles(hold.x, hold.y);
                                if (game.player.currentHold === hold) {
                                    game.player.grounded = false;
                                    game.player.snapping = false;
                                    game.player.vy = 100; // Small downward velocity
                                }
                            }, 300);
                        }
                        
                        break;
                    }
                }
            }
            
            // Check for fall to ground
            if (game.player.y > game.groundLevel + 50) {
                gameOver();
            }
            
            // Update height
            const newHeight = Math.max(0, Math.floor((game.groundLevel - game.player.y) / 10));
            
            // Check for milestones/checkpoints
            for (let milestone of game.milestones) {
                if (newHeight >= milestone && !game.checkpointsCollected.includes(milestone)) {
                    game.checkpointsCollected.push(milestone);
                    game.lastMilestone = milestone;
                    addMilestoneFlag(milestone);
                    game.coins += Math.floor(milestone / 10); // Bonus coins
                    
                    // Add 20 seconds to timer in solo mode
                    if (game.mode === 'solo' && game.timerActive) {
                        game.timer += 20;
                        showTimeBonus();
                    }
                    
                    vibrate(50);
                    break;
                }
            }
            
            game.height = newHeight;
            game.maxHeight = Math.max(game.maxHeight, game.height);
            
            // Update camera
            game.camera.targetY = game.player.y - canvas.height * 0.6;
            game.camera.y += (game.camera.targetY - game.camera.y) * 0.1;
            
            // Generate more holds
            if (-game.lastHoldY < -game.camera.y + canvas.height * 2) {
                addHold();
            }
            
            // Update moving holds - keep within cliff bounds
            for (let hold of game.holds) {
                if (hold.moving && !hold.broken) {
                    hold.x += hold.moveSpeed * hold.moveDir;
                    
                    // Use the hold's stored movement range
                    if (hold.x < hold.moveRangeLeft || hold.x > hold.moveRangeRight) {
                        hold.moveDir *= -1;
                        // Clamp to bounds
                        hold.x = Math.max(hold.moveRangeLeft, Math.min(hold.moveRangeRight, hold.x));
                    }
                }
            }
        }

        function updateParticles(dt) {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.life -= dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 500 * dt;
                
                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }
        }

        function createCoinParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                game.particles.push({
                    x: x,
                    y: y - 40,
                    vx: Math.cos(angle) * 100,
                    vy: Math.sin(angle) * 100 - 100,
                    life: 0.5,
                    color: '#ffd700'
                });
            }
        }

        function createJumpParticles(x, y, isBoosted = false) {
            const particleCount = isBoosted ? 12 : 6;
            const particleColor = isBoosted ? '#ffd700' : '#d4a78a';
            
            for (let i = 0; i < particleCount; i++) {
                game.particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * (isBoosted ? 200 : 100),
                    vy: Math.random() * (isBoosted ? 150 : 100),
                    life: isBoosted ? 0.5 : 0.3,
                    color: particleColor
                });
            }
        }

        function createBreakParticles(x, y) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 * i) / 12;
                const speed = 100 + Math.random() * 150;
                game.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 100,
                    life: 0.6,
                    color: '#8b7355'
                });
            }
        }

        function createImpactEffect(x, y, speed) {
            // Create shockwave ring effect
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const particleSpeed = 150 + Math.random() * 100;
                game.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * particleSpeed,
                    vy: Math.sin(angle) * particleSpeed,
                    life: 0.4,
                    color: '#ff6b6b'
                });
            }
            
            // Add extra dust particles
            for (let i = 0; i < 8; i++) {
                game.particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 200,
                    vy: -Math.random() * 200,
                    life: 0.5,
                    color: '#d4a78a'
                });
            }
        }

        function showMilestone(height) {
            const milestoneEl = document.createElement('div');
            milestoneEl.className = 'milestone-popup';
            milestoneEl.textContent = `üèîÔ∏è ${height}m MILESTONE!`;
            document.body.appendChild(milestoneEl);
            
            setTimeout(() => {
                milestoneEl.remove();
            }, 2000);
        }

        function addMilestoneFlag(height) {
            const flagY = game.groundLevel - (height * 10);
            game.milestoneFlags.push({
                height: height,
                y: flagY,
                leftSide: Math.random() > 0.5
            });
        }

        function winGame() {
            game.state = 'victory';
            game.player.celebrating = true;
            game.player.celebrationTime = 0;
            
            // Move player to summit position
            const summitY = game.groundLevel - (game.winThreshold * 10) - 100;
            game.player.y = summitY;
            game.player.x = canvas.width / 2;
            game.player.vx = 0;
            game.player.vy = 0;
            game.player.grounded = true;
            game.player.rotation = 0;
            
            vibrate(100);
            
            // Check multiplayer result
            let resultMessage = 'üèÜ SUMMIT REACHED!';
            if (game.mode === 'multiplayer') {
                // Check if player finished first
                const allFinished = game.npcs.filter(npc => npc.height >= game.winThreshold);
                if (allFinished.length === 0) {
                    resultMessage = 'ü•á FIRST PLACE!\nYOU WIN!';
                } else if (allFinished.length === 1) {
                    resultMessage = 'ü•à SECOND PLACE!\nNice climb!';
                } else if (allFinished.length === 2) {
                    resultMessage = 'ü•â THIRD PLACE!\nGood effort!';
                } else {
                    resultMessage = `${allFinished.length + 1}th PLACE\nKeep climbing!`;
                }
            }
            
            // Show victory after animation
            setTimeout(() => {
                game.totalCoins += game.coins;
                game.totalCoins += game.winThreshold; // Bonus for winning
                localStorage.setItem('climberCoins', game.totalCoins);
                game.completedRuns++;
                
                const oldThreshold = game.winThreshold;
                
                // Calculate next win threshold
                if (game.completedRuns === 1) {
                    game.winThreshold = 750;
                } else if (game.completedRuns === 2) {
                    game.winThreshold = 1000;
                } else {
                    game.winThreshold = 1000 + (game.completedRuns - 2) * 250;
                }
                
                alert(`${resultMessage}\n\nHeight: ${oldThreshold}m\n+${game.coins + oldThreshold} coins\n\nNext challenge: ${game.winThreshold}m`);
                
                // Reset game state but keep threshold increased
                resetGameForNextChallenge();
            }, 4000);
        }

        function resetGameForNextChallenge() {
            // Reset player position
            game.player.x = canvas.width / 2;
            game.player.y = game.groundLevel - 60;
            game.player.vx = 0;
            game.player.vy = 0;
            game.player.grounded = true;
            game.player.snapping = false;
            game.player.celebrating = false;
            game.player.celebrationTime = 0;
            game.player.rotation = 0;
            game.player.targetRotation = 0;
            game.player.jumpBoost = 1.0;
            game.player.reachableHolds = [];
            
            // Reset game data
            game.height = 0;
            game.maxHeight = 0;
            game.coins = 0;
            game.lastMilestone = 0;
            game.milestoneFlags = [];
            game.checkpointsCollected = [];
            
            // Reset timer for solo mode
            if (game.mode === 'solo') {
                game.timer = 60;
                game.timerActive = true;
            }
            
            // Regenerate holds
            generateHolds();
            
            // Reset camera
            game.camera.y = 0;
            game.camera.targetY = 0;
            
            // Reset state
            game.state = 'playing';
        }

        function updateLeaderboard() {
            if (game.mode !== 'multiplayer') {
                document.getElementById('leaderboard').style.display = 'none';
                return;
            }
            
            document.getElementById('leaderboard').style.display = 'block';
            
            // Collect all players
            const allPlayers = [
                { name: game.player.name, height: game.height, color: skins[game.player.skin]?.color || '#ff6b6b', isPlayer: true },
                ...game.npcs.map(npc => ({ name: npc.name, height: npc.height, color: npc.color, isPlayer: false }))
            ];
            
            // Sort by height descending
            allPlayers.sort((a, b) => b.height - a.height);
            
            // Build leaderboard HTML
            let html = '';
            for (let i = 0; i < allPlayers.length; i++) {
                const p = allPlayers[i];
                const position = i + 1;
                const medal = position === 1 ? 'ü•á' : position === 2 ? 'ü•à' : position === 3 ? 'ü•â' : `${position}.`;
                const highlight = p.isPlayer ? 'background: rgba(255, 215, 0, 0.2); border-left: 3px solid #ffd700;' : '';
                const fontWeight = p.isPlayer ? 'bold' : 'normal';
                
                html += `
                    <div style="padding: 6px 8px; margin: 4px 0; border-radius: 8px; ${highlight} display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #fff; text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9); font-weight: ${fontWeight};">
                            ${medal} <span style="color: ${p.color};">${p.name}</span>
                        </span>
                        <span style="color: #d4a78a; font-weight: bold; text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9);">${p.height}m</span>
                    </div>
                `;
            }
            
            document.getElementById('leaderboardList').innerHTML = html;
        }

        function updateRuler() {
            const rulerBg = document.getElementById('rulerBg');
            rulerBg.innerHTML = '';
            
            // Show simple height markers with checkpoints (endless climb)
            const markerInterval = 100;
            const displayHeight = Math.max(game.maxHeight + 300, 1000);
            
            for (let h = 0; h <= displayHeight; h += markerInterval) {
                const marker = document.createElement('div');
                marker.className = 'ruler-marker';
                
                const percent = (h / displayHeight) * 100;
                marker.style.bottom = percent + '%';
                
                // Highlight achieved heights
                if (h <= game.height) {
                    marker.style.background = '#d4a78a';
                    marker.style.opacity = '1';
                } else {
                    marker.style.opacity = '0.4';
                }
                
                // Show checkpoint markers
                if (game.milestones.includes(h)) {
                    const collected = game.checkpointsCollected.includes(h);
                    const text = document.createElement('div');
                    text.className = 'ruler-text';
                    text.textContent = collected ? '‚úì ' + h + 'm' : '‚è±Ô∏è ' + h + 'm';
                    text.style.bottom = `calc(${percent}% - 6px)`;
                    text.style.color = collected ? '#4ecdc4' : '#ffd700';
                    text.style.fontWeight = 'bold';
                    marker.appendChild(text);
                } else if (h % 500 === 0 && h > 0) {
                    const text = document.createElement('div');
                    text.className = 'ruler-text';
                    text.textContent = h + 'm';
                    text.style.bottom = `calc(${percent}% - 6px)`;
                    marker.appendChild(text);
                }
                
                rulerBg.appendChild(marker);
            }
            
            // Current height indicator
            const currentPercent = (game.height / displayHeight) * 100;
            const currentIndicator = document.createElement('div');
            currentIndicator.style.position = 'absolute';
            currentIndicator.style.bottom = currentPercent + '%';
            currentIndicator.style.left = '50%';
            currentIndicator.style.transform = 'translateX(-50%)';
            currentIndicator.style.width = '100%';
            currentIndicator.style.height = '3px';
            currentIndicator.style.background = '#ff6b6b';
            currentIndicator.style.boxShadow = '0 0 10px rgba(255, 107, 107, 0.8)';
            rulerBg.appendChild(currentIndicator);
        }

        // Render
        function render() {
            // Sky background
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(0.6, '#b8d4ea');
            skyGradient.addColorStop(1, '#e8d5c4');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw distant mountains in background
            ctx.fillStyle = 'rgba(120, 100, 80, 0.2)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height * 0.7);
            for (let i = 0; i <= canvas.width; i += 50) {
                ctx.lineTo(i, canvas.height * 0.7 + Math.sin(i * 0.01) * 30);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw animated clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            for (let i = 0; i < 8; i++) {
                const x = (i * 283.7 + game.time * 10) % (canvas.width + 100) - 50;
                const y = ((i * 157.3) % (canvas.height * 0.4));
                ctx.beginPath();
                ctx.ellipse(x, y, 50 + i * 4, 25 + i * 2, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.save();
            ctx.translate(0, -game.camera.y);
            
            // Draw cliff face with realistic vertical columns
            const baseCliffWidth = canvas.width * 0.6;
            const cliffCenterX = canvas.width / 2;
            const cliffStartY = Math.floor((game.camera.y - canvas.height) / 100) * 100;
            const cliffEndY = game.camera.y + canvas.height * 3;
            
            // Build cliff outline
            ctx.beginPath();
            let firstPoint = true;
            
            // Left edge
            for (let y = cliffStartY; y <= cliffEndY; y += 50) {
                const bounds = getCliffBounds(y);
                if (firstPoint) {
                    ctx.moveTo(bounds.left, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(bounds.left, y);
                }
            }
            
            // Right edge (going back up)
            for (let y = cliffEndY; y >= cliffStartY; y -= 50) {
                const bounds = getCliffBounds(y);
                ctx.lineTo(bounds.right, y);
            }
            
            ctx.closePath();
            
            // Fill base cliff color
            ctx.fillStyle = '#7a6954';
            ctx.fill();
            
            // Draw vertical striations to make it look like a real cliff
            const numColumns = 30;
            for (let i = 0; i < numColumns; i++) {
                const yStart = cliffStartY;
                const yEnd = cliffEndY;
                
                // Each column has slight variations
                const columnOffset = (i / numColumns) * baseCliffWidth;
                
                ctx.strokeStyle = i % 2 === 0 ? 'rgba(100, 85, 70, 0.4)' : 'rgba(110, 95, 80, 0.3)';
                ctx.lineWidth = 3 + Math.random() * 4;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                for (let y = yStart; y <= yEnd; y += 40) {
                    const bounds = getCliffBounds(y);
                    const cliffWidth = bounds.right - bounds.left;
                    
                    // Position column within cliff bounds
                    const x = bounds.left + (columnOffset / baseCliffWidth) * cliffWidth;
                    
                    // Add micro-variations for natural look
                    const wobble = Math.sin(y * 0.03 + i) * 2;
                    
                    if (y === yStart) {
                        ctx.moveTo(x + wobble, y);
                    } else {
                        ctx.lineTo(x + wobble, y);
                    }
                }
                ctx.stroke();
            }
            
            // Add darker vertical cracks between columns
            for (let i = 0; i < 8; i++) {
                const yStart = cliffStartY;
                const yEnd = cliffEndY;
                const crackOffset = ((i + 0.5) / 8) * baseCliffWidth;
                
                ctx.strokeStyle = 'rgba(40, 30, 25, 0.5)';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                for (let y = yStart; y <= yEnd; y += 60) {
                    const bounds = getCliffBounds(y);
                    const cliffWidth = bounds.right - bounds.left;
                    const x = bounds.left + (crackOffset / baseCliffWidth) * cliffWidth;
                    const wobble = Math.sin(y * 0.02 + i * 2) * 3;
                    
                    if (y === yStart) {
                        ctx.moveTo(x + wobble, y);
                    } else {
                        ctx.lineTo(x + wobble, y);
                    }
                }
                ctx.stroke();
            }
            
            // Draw ground at bottom - extends in all directions
            if (game.groundLevel - game.camera.y < canvas.height + 100) {
                const groundBounds = getCliffBounds(game.groundLevel);
                
                // Draw main ground platform extending outward
                const groundGradient = ctx.createLinearGradient(0, game.groundLevel, 0, game.groundLevel + 300);
                groundGradient.addColorStop(0, '#8b7355');
                groundGradient.addColorStop(0.3, '#6b5943');
                groundGradient.addColorStop(1, '#4a3f2f');
                ctx.fillStyle = groundGradient;
                
                // Ground extends from cliff edges outward and downward
                ctx.fillRect(0, game.groundLevel, canvas.width, 500);
                
                // Draw cliff base where it meets ground
                ctx.fillStyle = '#7a6954';
                ctx.fillRect(groundBounds.left, game.groundLevel - 20, groundBounds.right - groundBounds.left, 20);
                
                // Animated grass on cliff top at ground level
                ctx.fillStyle = '#6b8e23';
                for (let i = 0; i < 30; i++) {
                    const x = groundBounds.left + (i * ((groundBounds.right - groundBounds.left) / 30));
                    const sway = Math.sin(game.time * 2 + i * 0.5) * 2;
                    ctx.save();
                    ctx.translate(x, game.groundLevel);
                    ctx.rotate(sway * 0.1);
                    ctx.fillRect(-1.5, -2, 3, 8);
                    ctx.restore();
                }
            }
            
            
            // Draw milestone markers as white translucent dashed lines
            for (let milestone of game.milestones) {
                const milestoneY = game.groundLevel - (milestone * 10);
                
                if (milestoneY > game.camera.y - 50 && milestoneY < game.camera.y + canvas.height + 50) {
                    const bounds = getCliffBounds(milestoneY);
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([15, 15]);
                    ctx.beginPath();
                    ctx.moveTo(bounds.left, milestoneY);
                    ctx.lineTo(bounds.right, milestoneY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Draw milestone flags with animation
            for (let flag of game.milestoneFlags) {
                if (flag.y > game.camera.y - 50 && flag.y < game.camera.y + canvas.height + 50) {
                    const bounds = getCliffBounds(flag.y);
                    const edgeX = flag.leftSide ? bounds.left + 20 : bounds.right - 20;
                    
                    // Flag pole
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(edgeX, flag.y);
                    ctx.lineTo(edgeX, flag.y - 40);
                    ctx.stroke();
                    
                    // Animated flag (waving)
                    const wave = Math.sin(game.time * 3 + flag.y * 0.01) * 3;
                    ctx.fillStyle = '#d4a78a';
                    ctx.beginPath();
                    ctx.moveTo(edgeX, flag.y - 40);
                    ctx.lineTo(edgeX + (flag.leftSide ? 35 + wave : -35 + wave), flag.y - 30);
                    ctx.lineTo(edgeX, flag.y - 20);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#654321';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = flag.leftSide ? 'left' : 'right';
                    ctx.fillText(flag.height + 'm', edgeX + (flag.leftSide ? 5 : -5), flag.y - 27);
                }
            }
            
            // Draw decorations with animations
            for (let dec of game.decorations) {
                if (dec.y < game.camera.y - 50 || dec.y > game.camera.y + canvas.height + 50) continue;
                
                const bounds = getCliffBounds(dec.y);
                
                // Check if decoration is within cliff bounds
                if (dec.x < bounds.left || dec.x > bounds.right) continue;
                
                if (dec.type === 'shrub') {
                    const sway = Math.sin(game.time * 2 + dec.x * 0.01) * 2;
                    ctx.save();
                    ctx.translate(dec.x, dec.y);
                    ctx.scale(1 + sway * 0.05, 1 - sway * 0.05);
                    
                    ctx.fillStyle = '#4a7c2e';
                    ctx.beginPath();
                    ctx.arc(0, 0, dec.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#3a5f1e';
                    ctx.beginPath();
                    ctx.arc(-dec.size / 4, -dec.size / 6, dec.size / 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                } else if (dec.type === 'tree') {
                    const sway = Math.sin(game.time * 1.5 + dec.x * 0.01) * 3;
                    ctx.save();
                    ctx.translate(dec.x, dec.y);
                    ctx.rotate(sway * 0.02);
                    
                    ctx.fillStyle = '#5d4037';
                    ctx.fillRect(-4, -dec.size / 3, 8, dec.size / 2);
                    
                    ctx.fillStyle = '#4a7c2e';
                    ctx.beginPath();
                    ctx.moveTo(0, -dec.size);
                    ctx.lineTo(-dec.size / 2, -dec.size / 3);
                    ctx.lineTo(dec.size / 2, -dec.size / 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                } else if (dec.type === 'goat') {
                    // Detailed animated goat
                    ctx.save();
                    ctx.translate(dec.x, dec.y);
                    if (!dec.facingRight) ctx.scale(-1, 1);
                    
                    const bob = Math.sin(game.time * 2 + dec.x * 0.1) * 2;
                    ctx.translate(0, bob);
                    
                    // Body
                    ctx.fillStyle = '#f5f5f5';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, dec.size / 2, dec.size / 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Legs
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    const legBob = Math.sin(game.time * 3 + dec.x * 0.1) * 1;
                    ctx.beginPath();
                    ctx.moveTo(-dec.size / 4, dec.size / 3);
                    ctx.lineTo(-dec.size / 4, dec.size / 3 + 8 + legBob);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(dec.size / 6, dec.size / 3);
                    ctx.lineTo(dec.size / 6, dec.size / 3 + 8 - legBob);
                    ctx.stroke();
                    
                    // Head
                    ctx.fillStyle = '#f5f5f5';
                    ctx.beginPath();
                    ctx.arc(dec.size / 3, -dec.size / 4, dec.size / 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Snout
                    ctx.fillStyle = '#d4d4d4';
                    ctx.beginPath();
                    ctx.ellipse(dec.size / 2, -dec.size / 5, dec.size / 8, dec.size / 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(dec.size / 3 + 3, -dec.size / 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Horns
                    ctx.strokeStyle = '#3d2817';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(dec.size / 3 - 3, -dec.size / 2);
                    ctx.quadraticCurveTo(dec.size / 3 - 5, -dec.size / 2 - 8, dec.size / 3, -dec.size / 2 - 10);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(dec.size / 3 + 3, -dec.size / 2);
                    ctx.quadraticCurveTo(dec.size / 3 + 5, -dec.size / 2 - 8, dec.size / 3, -dec.size / 2 - 10);
                    ctx.stroke();
                    
                    // Tail
                    const tailWag = Math.sin(game.time * 4 + dec.x * 0.1) * 5;
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-dec.size / 2, 0);
                    ctx.lineTo(-dec.size / 2 - 5 + tailWag, -5);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Draw holds with subtle animation
            for (let hold of game.holds) {
                if (hold.broken) continue;
                
                const baseColor = hold.breakable ? '#8b5a3c' : 
                                 hold.moving ? '#a0826d' :
                                 '#7a6450';
                
                const pulse = hold.moving ? 1 + Math.sin(game.time * 3) * 0.05 : 1;
                
                ctx.fillStyle = baseColor;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 4;
                
                ctx.beginPath();
                ctx.ellipse(hold.x, hold.y, (hold.width / 2) * pulse, (hold.height / 2) * pulse, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.beginPath();
                ctx.ellipse(hold.x - hold.width / 5, hold.y - hold.height / 5, hold.width / 4, hold.height / 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(hold.x, hold.y + hold.height / 3, hold.width / 2.5, hold.height / 6, 0, 0, Math.PI);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw trajectory if aiming
            if (game.player.aimMode && game.player.grounded && game.player.powerPercent > 0) {
                const dx = game.player.aimCurrentX - game.player.x;
                const dy = game.player.aimCurrentY - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    const angle = Math.atan2(dy, dx);
                    const basePower = (250 + (game.player.powerPercent / 100) * 650) * 1.4;
                    const finalPower = basePower * game.player.jumpBoost;
                    const hasBooost = game.player.jumpBoost > 1.05;
                    
                    // Draw trajectory with boost coloring
                    ctx.strokeStyle = hasBooost ? 'rgba(255, 215, 0, 0.9)' : 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = hasBooost ? 5 : 3;
                    ctx.setLineDash([12, 12]);
                    
                    if (hasBooost) {
                        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
                        ctx.shadowBlur = 10;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(game.player.x, game.player.y);
                    
                    let px = game.player.x;
                    let py = game.player.y;
                    let pvx = Math.cos(angle) * finalPower;
                    let pvy = Math.sin(angle) * finalPower;
                    
                    for (let i = 0; i < 8; i++) {
                        pvy += 1500 * 0.05;
                        px += pvx * 0.05;
                        py += pvy * 0.05;
                        ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    
                    // Draw sparkles along boosted trajectory
                    if (hasBooost) {
                        ctx.fillStyle = '#ffd700';
                        px = game.player.x;
                        py = game.player.y;
                        pvx = Math.cos(angle) * finalPower;
                        pvy = Math.sin(angle) * finalPower;
                        
                        for (let i = 0; i < 5; i++) {
                            pvy += 1500 * 0.05;
                            px += pvx * 0.05;
                            py += pvy * 0.05;
                            
                            const sparkleSize = 2 + Math.sin(game.time * 8 + i) * 1;
                            ctx.beginPath();
                            ctx.arc(px, py, sparkleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // Draw aim point
                    ctx.fillStyle = hasBooost ? 'rgba(255, 215, 0, 0.9)' : 'rgba(139, 115, 85, 0.8)';
                    ctx.beginPath();
                    ctx.arc(game.player.aimCurrentX, game.player.aimCurrentY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Show boost multiplier text near aim point
                    if (hasBooost) {
                        ctx.fillStyle = '#ffd700';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`x${game.player.jumpBoost.toFixed(1)}`, game.player.aimCurrentX, game.player.aimCurrentY - 20);
                    }
                }
            }
            
            // Draw NPCs in multiplayer mode
            if (game.mode === 'multiplayer') {
                for (let npc of game.npcs) {
                    ctx.save();
                    ctx.translate(npc.x, npc.y);
                    ctx.rotate(npc.rotation);
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(0, npc.radius + 3, npc.radius * 0.8, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body
                    ctx.fillStyle = npc.color;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, npc.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Simple limbs
                    ctx.strokeStyle = npc.color;
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    
                    // Arms
                    ctx.beginPath();
                    ctx.moveTo(-5, -2);
                    ctx.lineTo(-10, -12);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(5, -2);
                    ctx.lineTo(10, -12);
                    ctx.stroke();
                    
                    // Legs
                    ctx.beginPath();
                    ctx.moveTo(-3, 7);
                    ctx.lineTo(-6, 14);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(3, 7);
                    ctx.lineTo(6, 14);
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // Name label above NPC
                    ctx.fillStyle = npc.color;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(npc.name, npc.x, npc.y - 25);
                    ctx.fillText(npc.name, npc.x, npc.y - 25);
                }
            }
            
            // Draw player with animation
            const skin = skins[game.player.skin] || skins.default;
            
            ctx.save();
            ctx.translate(game.player.x, game.player.y);
            
            // Celebration animation
            if (game.player.celebrating) {
                const jumpHeight = Math.abs(Math.sin(game.player.celebrationTime * 3)) * 20;
                ctx.translate(0, -jumpHeight);
                ctx.rotate(0); // Keep upright during celebration
                
                // Confetti particles
                if (Math.random() < 0.3) {
                    const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
                    game.particles.push({
                        x: game.player.x + (Math.random() - 0.5) * 40,
                        y: game.player.y - 30,
                        vx: (Math.random() - 0.5) * 200,
                        vy: -Math.random() * 300,
                        life: 1.0,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    });
                }
            } else {
                ctx.rotate(game.player.rotation);
            }
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(0, game.player.radius + 3, game.player.radius * 0.8, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.fillStyle = skin.color;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(0, 0, game.player.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Backpack
            ctx.fillStyle = '#654321';
            ctx.fillRect(-8, -2, 16, 12);
            
            // Animated limbs
            ctx.strokeStyle = skin.color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            if (game.player.celebrating) {
                // Victory pose - arms raised
                const wave = Math.sin(game.player.armAnimation) * 10;
                
                ctx.beginPath();
                ctx.moveTo(-6, -3);
                ctx.lineTo(-12 - wave, -25);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(6, -3);
                ctx.lineTo(12 + wave, -25);
                ctx.stroke();
                
                // Legs - standing
                ctx.beginPath();
                ctx.moveTo(-4, 8);
                ctx.lineTo(-8, 18);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(4, 8);
                ctx.lineTo(8, 18);
                ctx.stroke();
            } else {
                const armSwing = game.player.grounded ? Math.sin(game.player.armAnimation) * 3 : 0;
                const legSwing = game.player.grounded ? Math.sin(game.player.legAnimation) * 2 : 0;
                
                // Arms
                ctx.beginPath();
                ctx.moveTo(-6, -3);
                ctx.lineTo(-12 + armSwing, -14);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(6, -3);
                ctx.lineTo(12 - armSwing, -14);
                ctx.stroke();
                
                // Legs
                ctx.beginPath();
                ctx.moveTo(-4, 8);
                ctx.lineTo(-8 + legSwing, 16);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(4, 8);
                ctx.lineTo(8 - legSwing, 16);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Draw particles
            for (let p of game.particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life * 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            ctx.restore();
        }
        let touching = false;
        let touchId = null;
        let powerBarDragging = false;

        function updatePowerBar(clientX) {
            const powerBarContainer = document.getElementById('powerBarContainer');
            const rect = powerBarContainer.getBoundingClientRect();
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            const percent = Math.round((x / rect.width) * 100);
            
            game.player.powerPercent = percent;
            document.getElementById('powerFill').style.width = percent + '%';
            document.getElementById('powerPercentage').textContent = percent + '%';
        }

        function startAim(x, y) {
            if (game.state !== 'playing') return;
            if (!game.player.grounded) return;
            if (game.player.powerPercent === 0) return;
            
            // Convert screen coords to world coords
            const worldY = y + game.camera.y;
            
            game.player.aimMode = true;
            game.player.aimStartX = x;
            game.player.aimStartY = worldY;
            game.player.aimCurrentX = x;
            game.player.aimCurrentY = worldY;
        }

        function updateAim(x, y) {
            if (!game.player.aimMode) return;
            
            const worldY = y + game.camera.y;
            game.player.aimCurrentX = x;
            game.player.aimCurrentY = worldY;
        }

        // Analyze which holds are reachable with maximum normal jump power
        function analyzeReachableHolds() {
            const maxNormalPower = (250 + 650) * 1.4; // Max power at 100%
            game.player.reachableHolds = [];
            
            // Test 8 directions around the player
            const testAngles = [
                -Math.PI/2, // Up
                -Math.PI/3, // Up-right
                -2*Math.PI/3, // Up-left
                -Math.PI/4, // Diagonal up-right
                -3*Math.PI/4, // Diagonal up-left
                0, // Right (if hold is to the side)
                Math.PI, // Left
                -Math.PI/6 // Shallow up
            ];
            
            for (const angle of testAngles) {
                const reachable = simulateJumpPath(
                    game.player.x,
                    game.player.y,
                    angle,
                    maxNormalPower
                );
                
                for (const hold of reachable) {
                    if (!game.player.reachableHolds.includes(hold)) {
                        game.player.reachableHolds.push(hold);
                    }
                }
            }
            
            // Calculate required boost
            if (game.player.reachableHolds.length === 0) {
                // No holds reachable - calculate boost needed
                game.player.jumpBoost = calculateBoostMultiplier();
            } else {
                // Reset boost
                game.player.jumpBoost = 1.0;
            }
        }

        // Simulate a jump path and return which holds would be contacted
        function simulateJumpPath(startX, startY, angle, power) {
            const contactedHolds = [];
            const dt = 0.033; // ~30 fps simulation
            const maxSteps = 150; // Simulate ~5 seconds
            
            let x = startX;
            let y = startY;
            let vx = Math.cos(angle) * power;
            let vy = Math.sin(angle) * power;
            
            for (let step = 0; step < maxSteps; step++) {
                // Apply gravity
                vy += 1500 * dt;
                
                // Update position
                x += vx * dt;
                y += vy * dt;
                
                // Stop if fallen below starting position
                if (y > startY + 100) break;
                
                // Check collision with holds
                for (const hold of game.holds) {
                    if (hold.broken) continue;
                    if (contactedHolds.includes(hold)) continue;
                    
                    const dx = x - hold.x;
                    const dy = y - hold.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const collisionRadius = game.player.radius + Math.max(hold.width / 2, hold.height / 2);
                    
                    if (distance < collisionRadius) {
                        contactedHolds.push(hold);
                    }
                }
            }
            
            return contactedHolds;
        }

        // Calculate the boost multiplier needed to reach the next two highest holds
        function calculateBoostMultiplier() {
            // Find all holds above the player
            const holdsAbove = game.holds
                .filter(hold => !hold.broken && hold.y < game.player.y)
                .sort((a, b) => a.y - b.y); // Sort by Y (lowest Y = highest position)
            
            if (holdsAbove.length === 0) return 1.0;
            
            // Target the second highest hold, or first if there's only one
            const targetIndex = Math.min(1, holdsAbove.length - 1);
            const targetHold = holdsAbove[targetIndex];
            
            // Calculate distance to target
            const dx = targetHold.x - game.player.x;
            const dy = targetHold.y - game.player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Estimate required power multiplier
            // Base formula: power needed ‚âà sqrt(distance) * gravity compensation
            const basePower = (250 + 650) * 1.4;
            const requiredPower = Math.sqrt(Math.abs(dy) * 1500) * 1.5;
            const multiplier = requiredPower / basePower;
            
            // Clamp between 1.0 and 2.5 (don't make it too easy or too hard)
            return Math.max(1.0, Math.min(2.5, multiplier));
        }

        function releaseJump() {
            if (game.state !== 'playing') return;
            if (!game.player.aimMode) return;
            if (!game.player.grounded) return;
            
            game.player.aimMode = false;
            
            const dx = game.player.aimCurrentX - game.player.x;
            const dy = game.player.aimCurrentY - game.player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Need minimum drag distance
            if (distance < 20) {
                return;
            }
            
            const angle = Math.atan2(dy, dx);
            
            // Apply dynamic boost if no holds are reachable
            const basePower = (250 + (game.player.powerPercent / 100) * 650) * 1.4;
            const finalPower = basePower * game.player.jumpBoost;
            
            // Store the jump power percent for breakable hold checking
            game.player.lastJumpPowerPercent = game.player.powerPercent;
            
            // Show boost indicator if boost is active
            if (game.player.jumpBoost > 1.05) {
                showBoostIndicator(game.player.jumpBoost);
                vibrate(50);
            }
            
            // Mark the hold we're leaving with current timestamp
            if (game.player.currentHold) {
                game.player.currentHold.lastLeftTime = Date.now();
            }
            
            game.player.vx = Math.cos(angle) * finalPower;
            game.player.vy = Math.sin(angle) * finalPower;
            game.player.grounded = false;
            game.player.snapping = false;
            game.player.currentHold = null;
            
            createJumpParticles(game.player.x, game.player.y, game.player.jumpBoost > 1.05);
            vibrate(20);
        }

        function showTimeBonus() {
            const indicator = document.createElement('div');
            indicator.style.position = 'absolute';
            indicator.style.top = '50%';
            indicator.style.left = '50%';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.fontSize = '32px';
            indicator.style.fontWeight = 'bold';
            indicator.style.color = '#4ecdc4';
            indicator.style.textShadow = '0 0 20px rgba(78, 205, 196, 0.8), 0 4px 8px rgba(0, 0, 0, 0.8)';
            indicator.style.zIndex = '100';
            indicator.style.pointerEvents = 'none';
            indicator.textContent = '‚è±Ô∏è +20 SECONDS!';
            indicator.style.animation = 'fadeOut 1.5s ease-out';
            
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.remove();
            }, 1500);
        }

        function showBoostIndicator(multiplier) {
            const indicator = document.createElement('div');
            indicator.style.position = 'absolute';
            indicator.style.top = '50%';
            indicator.style.left = '50%';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.fontSize = '28px';
            indicator.style.fontWeight = 'bold';
            indicator.style.color = '#ffd700';
            indicator.style.textShadow = '0 0 20px rgba(255, 215, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.8)';
            indicator.style.zIndex = '100';
            indicator.style.pointerEvents = 'none';
            indicator.textContent = `‚ö° POWER BOOST x${multiplier.toFixed(1)}!`;
            indicator.style.animation = 'fadeOut 1.2s ease-out';
            
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.remove();
            }, 1200);
        }

        // Power bar interaction
        const powerBarContainer = document.getElementById('powerBarContainer');
        
        powerBarContainer.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            powerBarDragging = true;
            updatePowerBar(e.clientX);
        });

        powerBarContainer.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            powerBarDragging = true;
            const touch = e.touches[0];
            updatePowerBar(touch.clientX);
        });

        document.addEventListener('mousemove', (e) => {
            if (powerBarDragging) {
                updatePowerBar(e.clientX);
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (powerBarDragging) {
                const touch = e.touches[0];
                updatePowerBar(touch.clientX);
            }
        });

        document.addEventListener('mouseup', () => {
            powerBarDragging = false;
        });

        document.addEventListener('touchend', () => {
            powerBarDragging = false;
        });

        // Canvas touch handling for aiming
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (touchId !== null) return;
            if (powerBarDragging) return;
            
            const touch = e.touches[0];
            touchId = touch.identifier;
            touching = true;
            startAim(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touching) return;
            
            for (let touch of e.touches) {
                if (touch.identifier === touchId) {
                    updateAim(touch.clientX, touch.clientY);
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            for (let touch of e.changedTouches) {
                if (touch.identifier === touchId) {
                    touching = false;
                    touchId = null;
                    releaseJump();
                    break;
                }
            }
        }, { passive: false });

        // Mouse handling for canvas
        canvas.addEventListener('mousedown', (e) => {
            if (powerBarDragging) return;
            touching = true;
            startAim(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!touching) return;
            updateAim(e.clientX, e.clientY);
        });

        canvas.addEventListener('mouseup', (e) => {
            touching = false;
            releaseJump();
        });

        // NPC System for Multiplayer
        const npcNames = ['Alex', 'Sam', 'Riley', 'Jordan', 'Casey', 'Morgan'];
        const npcColors = ['#4ecdc4', '#ffe66d', '#95e1d3', '#a78bfa', '#ff9a56', '#ff6b9d'];
        
        function initializeNPCs() {
            game.npcs = [];
            const numNPCs = 3;
            
            for (let i = 0; i < numNPCs; i++) {
                game.npcs.push({
                    name: npcNames[i],
                    color: npcColors[i],
                    x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                    y: game.groundLevel - 60,
                    vx: 0,
                    vy: 0,
                    radius: 15,
                    currentHold: game.holds[0],
                    grounded: true,
                    snapping: false,
                    snapProgress: 0,
                    rotation: 0,
                    height: 0,
                    nextJumpTime: Date.now() + Math.random() * 1500 + 500,
                    skill: 0.75 + Math.random() * 0.25, // 0.75-1.0 skill level (much better)
                    reactionTime: 300 + Math.random() * 200, // 300-500ms reaction time
                    targetHold: null
                });
            }
        }
        
        function updateNPCs(dt) {
            if (game.mode !== 'multiplayer') return;
            
            const currentTime = Date.now();
            
            for (let npc of game.npcs) {
                // Update height
                npc.height = Math.max(0, Math.floor((game.groundLevel - npc.y) / 10));
                
                // Handle snapping
                if (npc.snapping && npc.currentHold) {
                    npc.snapProgress += dt * 8;
                    
                    if (npc.snapProgress >= 1) {
                        npc.snapping = false;
                        npc.grounded = true;
                        npc.vx = 0;
                        npc.vy = 0;
                        npc.x = npc.currentHold.x;
                        npc.y = npc.currentHold.y - npc.currentHold.height / 2 - npc.radius;
                        npc.targetHold = null;
                        
                        // Schedule next jump based on skill (better NPCs jump faster)
                        npc.nextJumpTime = currentTime + npc.reactionTime / npc.skill;
                    } else {
                        const targetX = npc.currentHold.x;
                        const targetY = npc.currentHold.y - npc.currentHold.height / 2 - npc.radius;
                        npc.x += (targetX - npc.x) * npc.snapProgress;
                        npc.y += (targetY - npc.y) * npc.snapProgress;
                    }
                    continue;
                }
                
                // AI jump logic
                if (npc.grounded && currentTime >= npc.nextJumpTime) {
                    npcJump(npc);
                }
                
                // Physics when airborne
                if (!npc.grounded) {
                    npc.vy += 1500 * dt;
                    npc.x += npc.vx * dt;
                    npc.y += npc.vy * dt;
                    npc.rotation = Math.atan2(npc.vy, npc.vx);
                    
                    // Collision detection
                    for (let hold of game.holds) {
                        if (hold.broken) continue;
                        
                        const dx = npc.x - hold.x;
                        const dy = npc.y - hold.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const collisionDist = npc.radius + Math.max(hold.width / 2, hold.height / 2);
                        
                        if (dist < collisionDist) {
                            // Check if this is a breakable hold and if NPC should break it
                            if (hold.breakable) {
                                const impactSpeed = Math.sqrt(npc.vx * npc.vx + npc.vy * npc.vy);
                                // NPCs can break holds on high-speed impacts
                                if (impactSpeed > 5000) {
                                    hold.broken = true;
                                    createBreakParticles(hold.x, hold.y);
                                    createImpactEffect(hold.x, hold.y, impactSpeed);
                                    npc.vx *= 0.3;
                                    npc.vy *= 0.3;
                                    continue;
                                }
                            }
                            
                            npc.currentHold = hold;
                            npc.snapping = true;
                            npc.snapProgress = 0;
                            break;
                        }
                    }
                }
                
                // Fall detection - respawn at ground
                if (npc.y > game.groundLevel + 50) {
                    npc.y = game.groundLevel - 60;
                    npc.x = canvas.width / 2 + (Math.random() - 0.5) * 100;
                    npc.vx = 0;
                    npc.vy = 0;
                    npc.grounded = true;
                    npc.height = 0;
                    npc.currentHold = game.holds[0];
                    npc.nextJumpTime = currentTime + 2000;
                }
            }
        }
        
        function npcJump(npc) {
            // Find reachable holds above using smart pathfinding
            const holdsAbove = game.holds.filter(hold => 
                !hold.broken && 
                hold.y < npc.y - 50 && // Must be significantly above
                Math.abs(hold.x - npc.x) < 300 // Within reasonable horizontal range
            ).sort((a, b) => a.y - b.y); // Sort by height (highest first)
            
            if (holdsAbove.length === 0) return;
            
            // Smart target selection based on skill
            let targetHold;
            
            if (npc.skill > 0.9) {
                // Expert NPCs: Look for optimal paths, skip breakables if possible
                const safeHolds = holdsAbove.filter(h => !h.breakable);
                const lookAhead = Math.min(5, safeHolds.length > 0 ? safeHolds.length : holdsAbove.length);
                targetHold = (safeHolds.length > 0 ? safeHolds : holdsAbove)[Math.floor(Math.random() * lookAhead)];
            } else if (npc.skill > 0.8) {
                // Good NPCs: Look ahead 2-3 holds
                const lookAhead = Math.min(3, holdsAbove.length);
                targetHold = holdsAbove[Math.floor(Math.random() * lookAhead)];
            } else {
                // Average NPCs: Look ahead 1-2 holds
                const lookAhead = Math.min(2, holdsAbove.length);
                targetHold = holdsAbove[Math.floor(Math.random() * lookAhead)];
            }
            
            if (!targetHold) return;
            
            npc.targetHold = targetHold;
            
            // Calculate optimal jump angle and power
            const dx = targetHold.x - npc.x;
            const dy = targetHold.y - npc.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Better NPCs use more optimal power calculations
            const optimalPower = Math.sqrt(Math.abs(dy) * 1500) * 1.5;
            const powerVariation = (1 - npc.skill) * 0.3; // Less variation for better NPCs
            const power = optimalPower * (1 + (Math.random() - 0.5) * powerVariation);
            
            // Calculate angle with slight randomness (less for better NPCs)
            const idealAngle = Math.atan2(dy, dx);
            const angleVariation = (1 - npc.skill) * 0.15; // Up to ¬±8.6 degrees for worst NPCs
            const angle = idealAngle + (Math.random() - 0.5) * angleVariation;
            
            npc.vx = Math.cos(angle) * power;
            npc.vy = Math.sin(angle) * power;
            npc.grounded = false;
            npc.snapping = false;
            npc.currentHold = null;
        }

        // Game loop with FPS limiting for mobile battery life
        let lastTime = Date.now();
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;
        let lastFrameTime = Date.now();
        
        function gameLoop() {
            const now = Date.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            const timeSinceLastFrame = now - lastFrameTime;
            
            // FPS limiting
            if (timeSinceLastFrame < FRAME_TIME) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            lastTime = now;
            lastFrameTime = now - (timeSinceLastFrame % FRAME_TIME);
            
            if (game.state === 'playing' || game.state === 'victory') {
                game.time += dt;
                updatePlayer(dt);
                updateNPCs(dt);
                updateParticles(dt);
                
                // Update timer in solo mode
                if (game.mode === 'solo' && game.timerActive && game.state === 'playing') {
                    game.timer -= dt;
                    
                    // Check if time ran out
                    if (game.timer <= 0) {
                        game.timer = 0;
                        game.timerActive = false;
                        gameOver();
                    }
                }
                
                if (game.state === 'playing') {
                    updateRuler();
                    updateLeaderboard();
                }
                
                // Update HUD
                document.getElementById('heightDisplay').textContent = `Height: ${game.height}m`;
                document.getElementById('coinsDisplay').textContent = `ü™ô ${game.coins}`;
                
                // Update timer display in solo mode
                if (game.mode === 'solo') {
                    const minutes = Math.floor(game.timer / 60);
                    const seconds = Math.floor(game.timer % 60);
                    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    const timerColor = game.timer < 10 ? '#ff6b6b' : '#4ecdc4';
                    document.getElementById('heightDisplay').textContent = `‚è±Ô∏è ${timeStr} ‚Ä¢ ${game.height}m`;
                    document.getElementById('heightDisplay').style.color = timerColor;
                } else {
                    document.getElementById('heightDisplay').style.color = '#d4a78a';
                }
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        // Game controls
        game.startGame = function(mode = 'solo') {
            game.mode = mode;
            game.state = 'playing';
            game.height = 0;
            game.maxHeight = 0;
            game.coins = 0;
            game.particles = [];
            game.continued = false;
            game.player.skin = game.selectedSkin;
            game.player.powerPercent = 50;
            game.player.aimMode = false;
            game.lastMilestone = 0;
            game.checkpointsCollected = [];
            
            // Initialize timer for solo mode
            if (mode === 'solo') {
                game.timer = 60;
                game.timerActive = true;
            } else {
                game.timerActive = false;
            }
            
            // Initialize NPCs for multiplayer
            if (mode === 'multiplayer') {
                initializeNPCs();
            } else {
                game.npcs = [];
            }
            
            generateHolds();
            
            document.getElementById('startScreen').classList.remove('active');
            document.getElementById('gameOverScreen').classList.remove('active');
            
            const skinsScreen = document.getElementById('skinsScreen');
            if (skinsScreen) {
                skinsScreen.classList.remove('active');
            }
            
            document.getElementById('powerBar').style.display = 'block';
            document.getElementById('heightRuler').style.display = 'block';
            document.getElementById('instruction').style.display = 'block';
            
            // Reset power bar display
            document.getElementById('powerFill').style.width = '50%';
            document.getElementById('powerPercentage').textContent = '50%';
            
            setTimeout(() => {
                document.getElementById('instruction').style.display = 'none';
            }, 4000);
        };

        game.showStart = function() {
            game.state = 'start';
            document.getElementById('startScreen').classList.add('active');
            document.getElementById('gameOverScreen').classList.remove('active');
            
            const skinsScreen = document.getElementById('skinsScreen');
            if (skinsScreen) {
                skinsScreen.classList.remove('active');
            }
            
            document.getElementById('powerBar').style.display = 'none';
            document.getElementById('heightRuler').style.display = 'none';
            document.getElementById('totalCoins').textContent = game.totalCoins;
        };

        game.showSkins = function() {
            const skinsScreen = document.getElementById('skinsScreen');
            if (!skinsScreen) {
                console.warn('Skins screen not available in this version');
                return;
            }
            
            document.getElementById('startScreen').classList.remove('active');
            skinsScreen.classList.add('active');
            
            const skinsCoins = document.getElementById('skinsCoins');
            if (skinsCoins) {
                skinsCoins.textContent = game.totalCoins;
            }
            
            if (typeof renderSkins === 'function') {
                renderSkins();
            }
        };

        game.watchAdToContinue = function() {
            if (game.continued) return;
            
            // Simulate ad
            alert('üì∫ Ad would play here!\n\nIn production, integrate AdMob or similar.');
            
            // Continue game
            game.continued = true;
            game.state = 'playing';
            document.getElementById('gameOverScreen').classList.remove('active');
            document.getElementById('powerBar').style.display = 'block';
            
            // Reset power
            game.player.powerPercent = 50;
            game.player.aimMode = false;
            document.getElementById('powerFill').style.width = '50%';
            document.getElementById('powerPercentage').textContent = '50%';
            
            // Place player on nearest hold
            let nearestHold = game.holds[0];
            let minDist = Infinity;
            
            for (let hold of game.holds) {
                if (hold.broken) continue;
                const dist = Math.abs(hold.y - game.player.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearestHold = hold;
                }
            }
            
            game.player.x = nearestHold.x;
            game.player.y = nearestHold.y - nearestHold.height / 2 - game.player.radius;
            game.player.grounded = true;
            game.player.vx = 0;
            game.player.vy = 0;
        };

        function gameOver() {
            if (game.state !== 'playing') return;
            
            game.state = 'gameOver';
            game.totalCoins += game.coins;
            localStorage.setItem('climberCoins', game.totalCoins);
            
            vibrate(50);
            
            document.getElementById('powerBar').style.display = 'none';
            document.getElementById('heightRuler').style.display = 'none';
            document.getElementById('finalHeight').textContent = game.maxHeight;
            document.getElementById('earnedCoins').textContent = game.coins;
            document.getElementById('gameOverScreen').classList.add('active');
        }

        function showCombo() {
            if (game.combo < 2) return;
            
            const comboEl = document.createElement('div');
            comboEl.className = 'combo';
            comboEl.textContent = `${game.combo}x COMBO!`;
            document.body.appendChild(comboEl);
            
            setTimeout(() => {
                comboEl.remove();
            }, 800);
        }

        function renderSkins() {
            const grid = document.getElementById('skinsGrid');
            grid.innerHTML = '';
            
            for (let [key, skin] of Object.entries(skins)) {
                const isUnlocked = game.unlockedSkins.includes(key);
                const isSelected = game.selectedSkin === key;
                
                const card = document.createElement('div');
                card.className = 'skin-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' locked' : '');
                
                const preview = document.createElement('div');
                preview.className = 'skin-preview';
                preview.style.background = skin.color;
                
                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = skin.name;
                
                const cost = document.createElement('div');
                cost.className = 'skin-cost';
                cost.textContent = isUnlocked ? (isSelected ? '‚úì EQUIPPED' : 'OWNED') : `ü™ô ${skin.cost}`;
                
                card.appendChild(preview);
                card.appendChild(name);
                card.appendChild(cost);
                
                card.onclick = () => {
                    if (isUnlocked) {
                        game.selectedSkin = key;
                        localStorage.setItem('climberSelectedSkin', key);
                        renderSkins();
                    } else {
                        if (game.totalCoins >= skin.cost) {
                            game.totalCoins -= skin.cost;
                            game.unlockedSkins.push(key);
                            game.selectedSkin = key;
                            localStorage.setItem('climberCoins', game.totalCoins);
                            localStorage.setItem('climberSkins', JSON.stringify(game.unlockedSkins));
                            localStorage.setItem('climberSelectedSkin', key);
                            document.getElementById('skinsCoins').textContent = game.totalCoins;
                            renderSkins();
                            vibrate(30);
                        } else {
                            alert(`Need ${skin.cost - game.totalCoins} more coins!`);
                        }
                    }
                };
                
                grid.appendChild(card);
            }
        }

        function vibrate(duration) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }

        // Start
        gameLoop();
        
        // Initialize game
        document.getElementById('totalCoins').textContent = game.totalCoins;
        
        // Hide loading screen
        setTimeout(() => {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
            }
        }, 500);
        
        console.log('Mountain Climber - Mobile Optimized Ready!');
        
        }); // End DOMContentLoaded
    </script>
</body>
</html>
